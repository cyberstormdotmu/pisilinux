>From 6519e6e5eb293f8a2e0f0ce1e8c1b35f4c0f923b Mon Sep 17 00:00:00 2001
From: Larry Finger <Larry.Finger@lwfinger.net>
Date: Fri, 11 Apr 2014 13:13:02 -0500
Subject: [PATCH 2/2] staging: r8192ee: Add new driver
To: linville@tuxdriver.com
Cc: netdev@vger.kernel.org

This is a temporary change until the regular version is ready.

Signed-off-by: Larry Finger <Larry.Finger@lwfinger.net>
---
 drivers/staging/rtl8192ee/base.c              | 119 +++-------------
 drivers/staging/rtl8192ee/base.h              |   4 +-
 drivers/staging/rtl8192ee/btcoexist/rtl_btc.c |   6 +-
 drivers/staging/rtl8192ee/btcoexist/rtl_btc.h |   2 +-
 drivers/staging/rtl8192ee/cam.c               |  43 +++---
 drivers/staging/rtl8192ee/cam.h               |  14 +-
 drivers/staging/rtl8192ee/compat.h            |  55 --------
 drivers/staging/rtl8192ee/core.c              | 188 ++------------------------
 drivers/staging/rtl8192ee/debug.c             |   4 -
 drivers/staging/rtl8192ee/efuse.c             |  45 +++---
 drivers/staging/rtl8192ee/efuse.h             |   6 +-
 drivers/staging/rtl8192ee/pci.c               | 148 ++------------------
 drivers/staging/rtl8192ee/pci.h               |  13 +-
 drivers/staging/rtl8192ee/ps.c                |  49 ++-----
 drivers/staging/rtl8192ee/ps.h                |   6 +-
 drivers/staging/rtl8192ee/rc.c                |  18 +--
 drivers/staging/rtl8192ee/regd.c              |  63 +--------
 drivers/staging/rtl8192ee/regd.h              |  16 ---
 drivers/staging/rtl8192ee/rtl8192ee/hw.c      |  43 +++---
 drivers/staging/rtl8192ee/rtl8192ee/led.c     |  34 ++---
 drivers/staging/rtl8192ee/rtl8192ee/phy.c     |   4 +-
 drivers/staging/rtl8192ee/rtl8192ee/sw.c      |  46 +++++--
 drivers/staging/rtl8192ee/rtl8192ee/trx.c     |  62 ++-------
 drivers/staging/rtl8192ee/rtl8192ee/trx.h     |  12 --
 drivers/staging/rtl8192ee/stats.c             |  21 ++-
 drivers/staging/rtl8192ee/stats.h             |   8 +-
 drivers/staging/rtl8192ee/wifi.h              |  29 ----
 27 files changed, 212 insertions(+), 846 deletions(-)

Index: linux-2.6/drivers/staging/rtl8192ee/base.c
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/base.c
+++ linux-2.6/drivers/staging/rtl8192ee/base.c
@@ -241,7 +241,6 @@ static void _rtl_init_hw_ht_capab(struct
 	}
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
 static void _rtl_init_hw_vht_capab(struct ieee80211_hw *hw,
 					struct ieee80211_sta_vht_cap *vht_cap)
 {
@@ -317,7 +316,6 @@ static void _rtl_init_hw_vht_capab(struc
 			MAX_BIT_RATE_SHORT_GI_1NSS_80MHZ_MCS9;
 	}
 }
-#endif
 
 static void _rtl_init_mac80211(struct ieee80211_hw *hw)
 {
@@ -357,9 +355,7 @@ static void _rtl_init_mac80211(struct ie
 		/* <3> init ht cap base on ant_num */
 		_rtl_init_hw_ht_capab(hw, &sband->ht_cap);
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
 		_rtl_init_hw_vht_capab(hw, &sband->vht_cap);
-#endif
 
 		/* <4> set mac->sband to wiphy->sband */
 		hw->wiphy->bands[IEEE80211_BAND_5GHZ] = sband;
@@ -392,9 +388,7 @@ static void _rtl_init_mac80211(struct ie
 			/* <3> init ht cap base on ant_num */
 			_rtl_init_hw_ht_capab(hw, &sband->ht_cap);
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
 			_rtl_init_hw_vht_capab(hw, &sband->vht_cap);
-#endif
 
 			/* <4> set mac->sband to wiphy->sband */
 			hw->wiphy->bands[IEEE80211_BAND_5GHZ] = sband;
@@ -406,9 +400,6 @@ static void _rtl_init_mac80211(struct ie
 	/* <5> set hw caps */
 	hw->flags = IEEE80211_HW_SIGNAL_DBM |
 	    IEEE80211_HW_RX_INCLUDES_FCS |
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0))
-	    IEEE80211_HW_BEACON_FILTER |
-#endif
 	    IEEE80211_HW_AMPDU_AGGREGATION |
 	    IEEE80211_HW_REPORTS_TX_ACK_STATUS |
 	    IEEE80211_HW_CONNECTION_MONITOR |
@@ -422,31 +413,16 @@ static void _rtl_init_mac80211(struct ie
 			/* IEEE80211_HW_SUPPORTS_DYNAMIC_PS | */
 			0;
 /*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-	hw->wiphy->interface_modes =
-	    BIT(NL80211_IFTYPE_AP) |
-	    BIT(NL80211_IFTYPE_STATION) |
-	    BIT(NL80211_IFTYPE_ADHOC) |
-	    BIT(NL80211_IFTYPE_MESH_POINT) |
-	    BIT(NL80211_IFTYPE_P2P_CLIENT) |
-	    BIT(NL80211_IFTYPE_P2P_GO);
-#else
-/*<delete in kernel end>*/
 	hw->wiphy->interface_modes =
-	    BIT(NL80211_IFTYPE_AP) |
-	    BIT(NL80211_IFTYPE_STATION) |
-	    BIT(NL80211_IFTYPE_ADHOC) |
-	    BIT(NL80211_IFTYPE_MESH_POINT);
-/*<delete in kernel start>*/
-#endif
-/*<delete in kernel end>*/
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39))
+		BIT(NL80211_IFTYPE_AP) |
+		BIT(NL80211_IFTYPE_STATION) |
+		BIT(NL80211_IFTYPE_ADHOC) |
+		BIT(NL80211_IFTYPE_MESH_POINT) |
+		BIT(NL80211_IFTYPE_P2P_CLIENT) |
+		BIT(NL80211_IFTYPE_P2P_GO);
 	hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
-#endif
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0))
 	hw->wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
-#endif
 
 	hw->wiphy->rts_threshold = 2347;
 
@@ -460,14 +436,10 @@ static void _rtl_init_mac80211(struct ie
 	hw->max_rate_tries = 4;
 	/* hw->max_rates = 1; */
 	hw->sta_data_size = sizeof(struct rtl_sta_info);
-#ifdef VIF_TODO
-	hw->vif_data_size = sizeof(struct rtl_vif_info);
-#endif
 
 /* wowlan is not supported by kernel if CONFIG_PM is not defined */
 #ifdef CONFIG_PM
 	if (rtlpriv->psc.wo_wlan_mode) {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0))
 		if (rtlpriv->psc.wo_wlan_mode & WAKE_ON_MAGIC_PACKET)
 			rtlpriv->wowlan.flags = WIPHY_WOWLAN_MAGIC_PKT;
 		if (rtlpriv->psc.wo_wlan_mode & WAKE_ON_PATTERN_MATCH) {
@@ -477,18 +449,6 @@ static void _rtl_init_mac80211(struct ie
 			rtlpriv->wowlan.pattern_max_len = MAX_WOL_PATTERN_SIZE;
 		}
 		hw->wiphy->wowlan = &(rtlpriv->wowlan);
-#else /* LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0) */
-		if (rtlpriv->psc.wo_wlan_mode & WAKE_ON_MAGIC_PACKET)
-			hw->wiphy->wowlan.flags = WIPHY_WOWLAN_MAGIC_PKT;
-		if (rtlpriv->psc.wo_wlan_mode & WAKE_ON_PATTERN_MATCH) {
-			hw->wiphy->wowlan.n_patterns =
-				MAX_SUPPORT_WOL_PATTERN_NUM;
-			hw->wiphy->wowlan.pattern_min_len =
-				MIN_WOL_PATTERN_SIZE;
-			hw->wiphy->wowlan.pattern_max_len =
-				MAX_WOL_PATTERN_SIZE;
-		}
-#endif
 	}
 #endif
 
@@ -500,7 +460,6 @@ static void _rtl_init_mac80211(struct ie
 		get_random_bytes((rtlmac + (ETH_ALEN - 1)), 1);
 		SET_IEEE80211_PERM_ADDR(hw, rtlmac);
 	}
-
 }
 
 static void _rtl_init_deferred_work(struct ieee80211_hw *hw)
@@ -516,15 +475,7 @@ static void _rtl_init_deferred_work(stru
 		    rtl_easy_concurrent_retrytimer_callback, (unsigned long)hw);
 	/* <2> work queue */
 	rtlpriv->works.hw = hw;
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-/*<delete in kernel end>*/
 	rtlpriv->works.rtl_wq = alloc_workqueue(rtlpriv->cfg->name, 0, 0);
-/*<delete in kernel start>*/
-#else
-	rtlpriv->works.rtl_wq = create_workqueue(rtlpriv->cfg->name);
-#endif
-/*<delete in kernel end>*/
 	INIT_DELAYED_WORK(&rtlpriv->works.watchdog_wq,
 			  (void *)rtl_watchdog_wq_callback);
 	INIT_DELAYED_WORK(&rtlpriv->works.ips_nic_off_wq,
@@ -695,15 +646,9 @@ static void _rtl_query_shortgi(struct ie
 
 	sgi_40 = sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40;
 	sgi_20 = sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
 	sgi_80 = sta->vht_cap.cap & IEEE80211_VHT_CAP_SHORT_GI_80;
-#endif
 
-	if ((!(sta->ht_cap.ht_supported))
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
-		&& (!(sta->vht_cap.vht_supported))
-#endif
-		)
+	if (!(sta->ht_cap.ht_supported) && !(sta->vht_cap.vht_supported))
 		return;
 
 	if (!sgi_40 && !sgi_20)
@@ -716,9 +661,7 @@ static void _rtl_query_shortgi(struct ie
 		 mac->opmode == NL80211_IFTYPE_ADHOC ||
 		 mac->opmode == NL80211_IFTYPE_MESH_POINT) {
 		bw_40 = sta->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
 		bw_80 = sta->vht_cap.vht_supported;
-#endif
 	}
 
 	if (bw_80 == true) {
@@ -862,7 +805,6 @@ static void _rtl_query_bandwidth_mode(st
 
 	tcb_desc->packet_bw = HT_CHANNEL_WIDTH_20_40;
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
 	if (rtlpriv->rtlhal.hw_type == HARDWARE_TYPE_RTL8812AE ||
 	    rtlpriv->rtlhal.hw_type == HARDWARE_TYPE_RTL8821AE) {
 		if (mac->opmode == NL80211_IFTYPE_AP ||
@@ -880,10 +822,8 @@ static void _rtl_query_bandwidth_mode(st
 			return;
 		tcb_desc->packet_bw = HT_CHANNEL_WIDTH_80;
 	}
-#endif
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
 static u8 _rtl_get_vht_highest_n_rate(struct ieee80211_hw *hw,
 				  struct ieee80211_sta *sta)
 {
@@ -920,7 +860,6 @@ static u8 _rtl_get_vht_highest_n_rate(st
 
 	return hw_rate;
 }
-#endif
 
 static u8 _rtl_get_highest_n_rate(struct ieee80211_hw *hw,
 				  struct ieee80211_sta *sta)
@@ -938,7 +877,7 @@ static u8 _rtl_get_highest_n_rate(struct
 	return hw_rate;
 }
 
-void rtl_get_tcb_desc(struct ieee80211_hw *hw,
+void stg_rtl_get_tcb_desc(struct ieee80211_hw *hw,
 		      struct ieee80211_tx_info *info,
 		      struct ieee80211_sta *sta,
 		      struct sk_buff *skb, struct rtl_tcb_desc *tcb_desc)
@@ -978,13 +917,10 @@ void rtl_get_tcb_desc(struct ieee80211_h
 			 *and N rate will all be controled by FW
 			 *when tcb_desc->use_driver_rate = false
 			 */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
 			if (sta && sta->vht_cap.vht_supported) {
 				tcb_desc->hw_rate =
 				_rtl_get_vht_highest_n_rate(hw, sta);
-			} else
-#endif
-			if (sta && (sta->ht_cap.ht_supported)) {
+			} else if (sta && (sta->ht_cap.ht_supported)) {
 				tcb_desc->hw_rate =
 					_rtl_get_highest_n_rate(hw, sta);
 			} else {
@@ -1016,7 +952,7 @@ void rtl_get_tcb_desc(struct ieee80211_h
 		tcb_desc->packet_bw = 0;
 	}
 }
-//EXPORT/g_SYMBOL(rtl_get_tcb_desc);
+EXPORT_SYMBOL(stg_rtl_get_tcb_desc);
 
 bool rtl_tx_mgmt_proc(struct ieee80211_hw *hw, struct sk_buff *skb)
 {
@@ -1106,17 +1042,10 @@ bool rtl_action_proc(struct ieee80211_hw
 									hdr->addr3,
 									tid);
 					if (skb_delba) {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
 						rx_status.freq =
 							hw->conf.chandef.chan->center_freq;
 						rx_status.band =
 							hw->conf.chandef.chan->band;
-#else
-						rx_status.freq =
-							hw->conf.channel->center_freq;
-						rx_status.band =
-							hw->conf.channel->band;
-#endif
 						rx_status.flag |= RX_FLAG_DECRYPTED;
 						rx_status.flag |= RX_FLAG_MACTIME_MPDU;
 						rx_status.rate_idx = 0;
@@ -1668,7 +1597,7 @@ struct sk_buff *rtl_make_smps_action(str
 	return skb;
 }
 
-int rtl_send_smps_action(struct ieee80211_hw *hw,
+int stg_rtl_send_smps_action(struct ieee80211_hw *hw,
 			 struct ieee80211_sta *sta,
 			 enum ieee80211_smps_mode smps)
 {
@@ -1708,28 +1637,15 @@ int rtl_send_smps_action(struct ieee8021
 		/* rtlpriv->cfg->ops->update_rate_tbl(hw, sta, 0); */
 
 		info->control.rates[0].idx = 0;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
 		info->band = hw->conf.chandef.chan->band;
-#else
-		info->band = hw->conf.channel->band;
-#endif
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
-		info->control.sta = sta;
-		rtlpriv->intf_ops->adapter_tx(hw, skb, &tcb_desc);
-#else
-/*<delete in kernel end>*/
 		rtlpriv->intf_ops->adapter_tx(hw, sta, skb, &tcb_desc);
-/*<delete in kernel start>*/
-#endif
-/*<delete in kernel end>*/
 	}
 	return 1;
 
 err_free:
 	return 0;
 }
-//EXPORT/g_SYMBOL(rtl_send_smps_action);
+EXPORT_SYMBOL(stg_rtl_send_smps_action);
 
 /* because mac80211 have issues when can receive del ba
  * so here we just make a fake del_ba if we receive a ba_req
@@ -2076,13 +1992,15 @@ static int __init rtl_core_module_init(v
 int  rtl_core_module_init(void)
 #endif
 {
+	static int here_once;
+
+	if (here_once++)
+		return 0;
+
 	if (rtl_rate_control_register())
 		printk(KERN_DEBUG "rtl: Unable to register rtl_rc,"
 			  "use default RC !!\n");
 
-	/* add proc for debug */
-	rtl_proc_add_topdir();
-
 	/* init some global vars */
 	INIT_LIST_HEAD(&global_var.glb_priv_list);
 	spin_lock_init(&global_var.glb_list_lock);
@@ -2097,9 +2015,6 @@ void  rtl_core_module_exit(void)
 {
 	/*RC*/
 	rtl_rate_control_unregister();
-
-	/* add proc for debug */
-	rtl_proc_remove_topdir();
 }
 
 #ifdef BUILD_ALONE
Index: linux-2.6/drivers/staging/rtl8192ee/base.h
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/base.h
+++ linux-2.6/drivers/staging/rtl8192ee/base.h
@@ -148,12 +148,12 @@ int rtl_rx_agg_stop(struct ieee80211_hw
 void rtl_watchdog_wq_callback(void *data);
 void rtl_fwevt_wq_callback(void *data);
 
-void rtl_get_tcb_desc(struct ieee80211_hw *hw,
+void stg_rtl_get_tcb_desc(struct ieee80211_hw *hw,
 		      struct ieee80211_tx_info *info,
 		      struct ieee80211_sta *sta,
 		      struct sk_buff *skb, struct rtl_tcb_desc *tcb_desc);
 
-int rtl_send_smps_action(struct ieee80211_hw *hw,
+int stg_rtl_send_smps_action(struct ieee80211_hw *hw,
 		struct ieee80211_sta *sta,
 		enum ieee80211_smps_mode smps);
 u8 *rtl_find_ie(u8 *data, unsigned int len, u8 ie);
Index: linux-2.6/drivers/staging/rtl8192ee/btcoexist/rtl_btc.c
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/btcoexist/rtl_btc.c
+++ linux-2.6/drivers/staging/rtl8192ee/btcoexist/rtl_btc.c
@@ -175,11 +175,11 @@ void rtl_btc_special_packet_notify(struc
 	return exhalbtc_special_packet_notify(&gl_bt_coexist, pkt_type);
 }
 
-struct rtl_btc_ops *rtl_btc_get_ops_pointer(void)
+struct rtl_btc_ops *stg_rtl_btc_get_ops_pointer(void)
 {
 	return &rtl_btc_operation;
 }
-//EXPORT/g_SYMBOL(rtl_btc_get_ops_pointer);
+EXPORT_SYMBOL(stg_rtl_btc_get_ops_pointer);
 
 u8 rtl_get_hwpg_ant_num(struct rtl_priv *rtlpriv)
 {
@@ -240,4 +240,4 @@ static void __exit rtl_btcoexist_module_
 
 module_init(rtl_btcoexist_module_init);
 module_exit(rtl_btcoexist_module_exit);
-#endif
+#endif
\ No newline at end of file
Index: linux-2.6/drivers/staging/rtl8192ee/btcoexist/rtl_btc.h
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/btcoexist/rtl_btc.h
+++ linux-2.6/drivers/staging/rtl8192ee/btcoexist/rtl_btc.h
@@ -51,7 +51,7 @@ void rtl_btc_special_packet_notify(struc
 
 
 //extern struct rtl_btc_ops rtl_btc_operation;
-extern struct rtl_btc_ops *rtl_btc_get_ops_pointer(void);
+extern struct rtl_btc_ops *stg_rtl_btc_get_ops_pointer(void);
 
 u8 rtl_get_hwpg_ant_num(struct rtl_priv *rtlpriv);
 u8 rtl_get_hwpg_bt_exist(struct rtl_priv *rtlpriv);
Index: linux-2.6/drivers/staging/rtl8192ee/cam.c
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/cam.c
+++ linux-2.6/drivers/staging/rtl8192ee/cam.c
@@ -28,9 +28,6 @@
  *****************************************************************************/
 #include "wifi.h"
 #include "cam.h"
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
-#include <linux/export.h>
-#endif
 
 void rtl_cam_reset_sec_info(struct ieee80211_hw *hw)
 {
@@ -121,7 +118,7 @@ static void rtl_cam_program_entry(struct
 		 ("after set key, usconfig:%x\n", us_config));
 }
 
-u8 rtl_cam_add_one_entry(struct ieee80211_hw *hw, u8 *mac_addr,
+u8 stg_rtl_cam_add_one_entry(struct ieee80211_hw *hw, u8 *mac_addr,
 			 u32 ul_key_id, u32 ul_entry_idx, u32 ul_enc_alg,
 			 u32 ul_default_key, u8 *key_content)
 {
@@ -154,9 +151,9 @@ u8 rtl_cam_add_one_entry(struct ieee8021
 	return 1;
 
 }
-//EXPORT/g_SYMBOL(rtl_cam_add_one_entry);
+EXPORT_SYMBOL(stg_rtl_cam_add_one_entry);
 
-int rtl_cam_delete_one_entry(struct ieee80211_hw *hw,
+int stg_rtl_cam_delete_one_entry(struct ieee80211_hw *hw,
 			     u8 *mac_addr, u32 ul_key_id)
 {
 	u32 ul_command;
@@ -171,16 +168,16 @@ int rtl_cam_delete_one_entry(struct ieee
 	rtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM], ul_command);
 
 	RT_TRACE(COMP_SEC, DBG_DMESG,
-		 ("rtl_cam_delete_one_entry(): WRITE A4: %x \n", 0));
+		 ("stg_rtl_cam_delete_one_entry(): WRITE A4: %x \n", 0));
 	RT_TRACE(COMP_SEC, DBG_DMESG,
-		 ("rtl_cam_delete_one_entry(): WRITE A0: %x \n", ul_command));
+		 ("stg_rtl_cam_delete_one_entry(): WRITE A0: %x \n", ul_command));
 
 	return 0;
 
 }
-//EXPORT/g_SYMBOL(rtl_cam_delete_one_entry);
+EXPORT_SYMBOL(stg_rtl_cam_delete_one_entry);
 
-void rtl_cam_reset_all_entry(struct ieee80211_hw *hw)
+void stg_rtl_cam_reset_all_entry(struct ieee80211_hw *hw)
 {
 	u32 ul_command;
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
@@ -188,9 +185,9 @@ void rtl_cam_reset_all_entry(struct ieee
 	ul_command = BIT(31) | BIT(30);
 	rtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM], ul_command);
 }
-//EXPORT/g_SYMBOL(rtl_cam_reset_all_entry);
+EXPORT_SYMBOL(stg_rtl_cam_reset_all_entry);
 
-void rtl_cam_mark_invalid(struct ieee80211_hw *hw, u8 uc_index)
+void stg_rtl_cam_mark_invalid(struct ieee80211_hw *hw, u8 uc_index)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 
@@ -225,13 +222,13 @@ void rtl_cam_mark_invalid(struct ieee802
 	rtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM], ul_command);
 
 	RT_TRACE(COMP_SEC, DBG_DMESG,
-		 ("rtl_cam_mark_invalid(): WRITE A4: %x \n", ul_content));
+		 ("stg_rtl_cam_mark_invalid(): WRITE A4: %x \n", ul_content));
 	RT_TRACE(COMP_SEC, DBG_DMESG,
-		 ("rtl_cam_mark_invalid(): WRITE A0: %x \n", ul_command));
+		 ("stg_rtl_cam_mark_invalid(): WRITE A0: %x \n", ul_command));
 }
-//EXPORT/g_SYMBOL(rtl_cam_mark_invalid);
+EXPORT_SYMBOL(stg_rtl_cam_mark_invalid);
 
-void rtl_cam_empty_entry(struct ieee80211_hw *hw, u8 uc_index)
+void stg_rtl_cam_empty_entry(struct ieee80211_hw *hw, u8 uc_index)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 
@@ -275,17 +272,17 @@ void rtl_cam_empty_entry(struct ieee8021
 		rtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM], ul_command);
 
 		RT_TRACE(COMP_SEC, DBG_LOUD,
-			 ("rtl_cam_empty_entry(): WRITE A4: %x \n",
+			 ("stg_rtl_cam_empty_entry(): WRITE A4: %x \n",
 			  ul_content));
 		RT_TRACE(COMP_SEC, DBG_LOUD,
-			 ("rtl_cam_empty_entry(): WRITE A0: %x \n",
+			 ("stg_rtl_cam_empty_entry(): WRITE A0: %x \n",
 			  ul_command));
 	}
 
 }
-//EXPORT/g_SYMBOL(rtl_cam_empty_entry);
+EXPORT_SYMBOL(stg_rtl_cam_empty_entry);
 
-u8 rtl_cam_get_free_entry(struct ieee80211_hw *hw, u8 *sta_addr)
+u8 stg_rtl_cam_get_free_entry(struct ieee80211_hw *hw, u8 *sta_addr)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	u32 bitmap = (rtlpriv->sec.hwsec_cam_bitmap) >> 4;
@@ -318,9 +315,9 @@ u8 rtl_cam_get_free_entry(struct ieee802
 	}
 	return TOTAL_CAM_ENTRY;
 }
-//EXPORT/g_SYMBOL(rtl_cam_get_free_entry);
+EXPORT_SYMBOL(stg_rtl_cam_get_free_entry);
 
-void rtl_cam_del_entry(struct ieee80211_hw *hw, u8 *sta_addr)
+void stg_rtl_cam_del_entry(struct ieee80211_hw *hw, u8 *sta_addr)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	u32 bitmap;
@@ -352,4 +349,4 @@ void rtl_cam_del_entry(struct ieee80211_
 	}
 	return;
 }
-//EXPORT/g_SYMBOL(rtl_cam_del_entry);
+EXPORT_SYMBOL(stg_rtl_cam_del_entry);
Index: linux-2.6/drivers/staging/rtl8192ee/cam.h
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/cam.h
+++ linux-2.6/drivers/staging/rtl8192ee/cam.h
@@ -41,16 +41,16 @@
 #define	CAM_CONFIG_USEDK				1
 #define	CAM_CONFIG_NO_USEDK				0
 
-extern void rtl_cam_reset_all_entry(struct ieee80211_hw *hw);
-extern u8 rtl_cam_add_one_entry(struct ieee80211_hw *hw, u8 *mac_addr,
+extern void stg_rtl_cam_reset_all_entry(struct ieee80211_hw *hw);
+extern u8 stg_rtl_cam_add_one_entry(struct ieee80211_hw *hw, u8 *mac_addr,
 				u32 ul_key_id, u32 ul_entry_idx, u32 ul_enc_alg,
 				u32 ul_default_key, u8 *key_content);
-int rtl_cam_delete_one_entry(struct ieee80211_hw *hw, u8 *mac_addr,
+int stg_rtl_cam_delete_one_entry(struct ieee80211_hw *hw, u8 *mac_addr,
 			     u32 ul_key_id);
-void rtl_cam_mark_invalid(struct ieee80211_hw *hw, u8 uc_index);
-void rtl_cam_empty_entry(struct ieee80211_hw *hw, u8 uc_index);
+void stg_rtl_cam_mark_invalid(struct ieee80211_hw *hw, u8 uc_index);
+void stg_rtl_cam_empty_entry(struct ieee80211_hw *hw, u8 uc_index);
 void rtl_cam_reset_sec_info(struct ieee80211_hw *hw);
-u8 rtl_cam_get_free_entry(struct ieee80211_hw *hw, u8 *sta_addr);
-void rtl_cam_del_entry(struct ieee80211_hw *hw, u8 *sta_addr);
+u8 stg_rtl_cam_get_free_entry(struct ieee80211_hw *hw, u8 *sta_addr);
+void stg_rtl_cam_del_entry(struct ieee80211_hw *hw, u8 *sta_addr);
 
 #endif
Index: linux-2.6/drivers/staging/rtl8192ee/compat.h
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/compat.h
+++ linux-2.6/drivers/staging/rtl8192ee/compat.h
@@ -1,65 +1,10 @@
 #ifndef __RTL_COMPAT_H__
 #define __RTL_COMPAT_H__
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29))
-/*
- * Use this if you want to use the same suspend and resume callbacks for suspend
- * to RAM and hibernation.
- */
-#define SIMPLE_DEV_PM_OPS(name, suspend_fn, resume_fn) \
-struct dev_pm_ops name = { \
-	.suspend = suspend_fn, \
-	.resume = resume_fn, \
-	.freeze = suspend_fn, \
-	.thaw = resume_fn, \
-	.poweroff = suspend_fn, \
-	.restore = resume_fn, \
-}
 
-#define compat_pci_suspend(fn)						\
-	int fn##_compat(struct pci_dev *pdev, pm_message_t state)	\
-	{								\
-		int r;							\
-									\
-		r = fn(&pdev->dev);					\
-		if (r)							\
-			return r;					\
-									\
-		pci_save_state(pdev);					\
-		pci_disable_device(pdev);				\
-		pci_set_power_state(pdev, PCI_D3hot);			\
-									\
-		return 0;						\
-	}
-
-#define compat_pci_resume(fn)						\
-	int fn##_compat(struct pci_dev *pdev)				\
-	{								\
-		int r;							\
-									\
-		pci_set_power_state(pdev, PCI_D0);			\
-		r = pci_enable_device(pdev);				\
-		if (r)							\
-			return r;					\
-		pci_restore_state(pdev);				\
-									\
-		return fn(&pdev->dev);					\
-	}
-#endif
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 39))
-#define RX_FLAG_MACTIME_MPDU RX_FLAG_TSFT
-#else
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
 #define RX_FLAG_MACTIME_MPDU RX_FLAG_MACTIME_START
-#else
-#endif
-/*#define NETDEV_TX_OK*/
-#endif
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0))
 #define IEEE80211_KEY_FLAG_SW_MGMT IEEE80211_KEY_FLAG_SW_MGMT_TX
-#endif
 
 struct ieee80211_mgmt_compat {
 	__le16 frame_control;
Index: linux-2.6/drivers/staging/rtl8192ee/core.c
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/core.c
+++ linux-2.6/drivers/staging/rtl8192ee/core.c
@@ -94,42 +94,9 @@ static void rtl_op_stop(struct ieee80211
 	mutex_unlock(&rtlpriv->locks.conf_mutex);
 }
 
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 39))
-static int rtl_op_tx(struct ieee80211_hw *hw, struct sk_buff *skb)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
-	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
-	struct rtl_tcb_desc tcb_desc;
-	memset(&tcb_desc, 0, sizeof(struct rtl_tcb_desc));
-
-	if (unlikely(is_hal_stop(rtlhal) || ppsc->rfpwr_state != ERFON))
-		goto err_free;
-
-	if (!test_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status))
-		goto err_free;
-
-	if (!rtlpriv->intf_ops->waitq_insert(hw, skb))
-		rtlpriv->intf_ops->adapter_tx(hw, skb, &tcb_desc);
-
-	return NETDEV_TX_OK;
-
-err_free:
-	dev_kfree_skb_any(skb);
-	return NETDEV_TX_OK;
-}
-#else
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
-static void rtl_op_tx(struct ieee80211_hw *hw, struct sk_buff *skb)
-#else
-/*<delete in kernel end>*/
 static void rtl_op_tx(struct ieee80211_hw *hw,
 		      struct ieee80211_tx_control *control,
 		      struct sk_buff *skb)
-/*<delete in kernel start>*/
-#endif
-/*<delete in kernel end>*/
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
@@ -143,26 +110,14 @@ static void rtl_op_tx(struct ieee80211_h
 	if (!test_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status))
 		goto err_free;
 
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
-	if (!rtlpriv->intf_ops->waitq_insert(hw, skb))
-		rtlpriv->intf_ops->adapter_tx(hw, skb, &tcb_desc);
-#else
-/*<delete in kernel end>*/
 	if (!rtlpriv->intf_ops->waitq_insert(hw, control->sta, skb))
 		rtlpriv->intf_ops->adapter_tx(hw, control->sta, skb, &tcb_desc);
-/*<delete in kernel start>*/
-#endif
-/*<delete in kernel end>*/
 	return;
 
 err_free:
 	dev_kfree_skb_any(skb);
 	return;
 }
-/*<delete in kernel start>*/
-#endif
-/*<delete in kernel end>*/
 
 static int rtl_op_add_interface(struct ieee80211_hw *hw,
 		struct ieee80211_vif *vif)
@@ -177,26 +132,15 @@ static int rtl_op_add_interface(struct i
 		return -EOPNOTSUPP;
 	}
 
-/*This flag is not defined before kernel 3.4*/
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
 	vif->driver_flags |= IEEE80211_VIF_BEACON_FILTER;
-#endif
 
 	rtl_ips_nic_on(hw);
 
 	mutex_lock(&rtlpriv->locks.conf_mutex);
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 	switch (ieee80211_vif_type_p2p(vif)) {
 	case NL80211_IFTYPE_P2P_CLIENT:
 		mac->p2p = P2P_ROLE_CLIENT;
 		/*fall through*/
-#else
-/*<delete in kernel end>*/
-	switch (vif->type) {
-/*<delete in kernel start>*/
-#endif
-/*<delete in kernel end>*/
 	case NL80211_IFTYPE_STATION:
 		if (mac->beacon_enabled == 1) {
 			RT_TRACE(COMP_MAC80211, DBG_LOUD,
@@ -220,13 +164,9 @@ static int rtl_op_add_interface(struct i
 				(u8 *) (&mac->basic_rates));
 
 		break;
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 	case NL80211_IFTYPE_P2P_GO:
 		mac->p2p = P2P_ROLE_GO;
 		/*fall through*/
-#endif
-/*<delete in kernel end>*/
 	case NL80211_IFTYPE_AP:
 		RT_TRACE(COMP_MAC80211, DBG_LOUD,
 			 ("NL80211_IFTYPE_AP \n"));
@@ -317,8 +257,6 @@ static void rtl_op_remove_interface(stru
 	mutex_unlock(&rtlpriv->locks.conf_mutex);
 }
 /*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-/*<delete in kernel end>*/
 static int rtl_op_change_interface(struct ieee80211_hw *hw,
 				   struct ieee80211_vif *vif,
 				   enum nl80211_iftype new_type, bool p2p)
@@ -334,9 +272,6 @@ static int rtl_op_change_interface(struc
 		 (" p2p  %x\n", p2p));
 	return ret;
 }
-/*<delete in kernel start>*/
-#endif
-/*<delete in kernel end>*/
 
 #ifdef CONFIG_PM
 u16 crc16_ccitt(u8 data, u16 crc)
@@ -392,11 +327,7 @@ static void _rtl_add_wowlan_patterns(str
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_mac *mac = &(rtlpriv->mac80211);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 12, 0))
 	struct cfg80211_pkt_pattern *patterns = wow->patterns;
-#else
-	struct cfg80211_wowlan_trig_pkt_pattern *patterns = wow->patterns;
-#endif
 	struct rtl_wow_pattern rtl_pattern;
 	u8 *pattern_os, *mask_os;
 	u8 mask[MAX_WOL_BIT_MASK_SIZE] = {0};
@@ -619,22 +550,14 @@ static int rtl_op_config(struct ieee8021
 	}
 
 	if (changed & IEEE80211_CONF_CHANGE_CHANNEL && rtlpriv->proximity.proxim_on == false) {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
 		struct ieee80211_channel *channel = hw->conf.chandef.chan;
 		enum nl80211_chan_width width = hw->conf.chandef.width;
-#else
-		struct ieee80211_channel *channel = hw->conf.channel;
-#endif
 		u8 wide_chan = (u8) channel->hw_value;
 		enum nl80211_channel_type channel_type = NL80211_CHAN_NO_HT;
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
 		/* channel_type is for 20&40M */
 		if (width < NL80211_CHAN_WIDTH_80)
 			channel_type = cfg80211_get_chandef_type(&(hw->conf.chandef));
-#else
-		channel_type = hw->conf.channel_type;
-#endif
 		if (mac->act_scanning)
 			mac->n_channels++;
 
@@ -655,7 +578,6 @@ static int rtl_op_config(struct ieee8021
 		 *it here based on UPPER & LOWER
 		 */
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
 		if (width >= NL80211_CHAN_WIDTH_80) {
 			if (width == NL80211_CHAN_WIDTH_80) {
 				u32 center_freq = hw->conf.chandef.center_freq1;
@@ -696,9 +618,7 @@ static int rtl_op_config(struct ieee8021
 					}
 				}
 			}
-		} else
-#endif
-		{
+		} else {
 			switch (channel_type) {
 			case NL80211_CHAN_HT20:
 			case NL80211_CHAN_NO_HT:
@@ -878,10 +798,8 @@ static int rtl_op_sta_add(struct ieee802
 			sta_entry->wireless_mode = WIRELESS_MODE_A;
 			if (sta->ht_cap.ht_supported == true)
 				sta_entry->wireless_mode = WIRELESS_MODE_N_5G;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
 			if (sta->vht_cap.vht_supported == true)
 				sta_entry->wireless_mode = WIRELESS_MODE_AC_5G;
-#endif
 
 			if (vif->type == NL80211_IFTYPE_ADHOC)
 				sta_entry->wireless_mode = WIRELESS_MODE_A;
@@ -945,14 +863,9 @@ static int _rtl_get_hal_qnum(u16 queue)
  *for mac80211 VO=0, VI=1, BE=2, BK=3
  *for rtl819x  BE=0, BK=1, VI=2, VO=3
  */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
 static int rtl_op_conf_tx(struct ieee80211_hw *hw,
 			  struct ieee80211_vif *vif, u16 queue,
 			  const struct ieee80211_tx_queue_params *param)
-#else
-static int rtl_op_conf_tx(struct ieee80211_hw *hw, u16 queue,
-			  const struct ieee80211_tx_queue_params *param)
-#endif
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
@@ -1042,7 +955,7 @@ static void rtl_op_bss_info_changed(stru
 			rtl_cam_reset_sec_info(hw);
 			/* reset cam to fix wep fail issue
 			 * when change from wpa to wep */
-			rtl_cam_reset_all_entry(hw);
+			stg_rtl_cam_reset_all_entry(hw);
 
 			mac->link_state = MAC80211_LINKED;
 			mac->cnt_after_linked = 0;
@@ -1061,7 +974,7 @@ static void rtl_op_bss_info_changed(stru
 					("send PS STATIC frame \n"));
 			if (rtlpriv->dm.supp_phymode_switch) {
 				if (sta->ht_cap.ht_supported)
-					rtl_send_smps_action(hw, sta,
+					stg_rtl_send_smps_action(hw, sta,
 							IEEE80211_SMPS_STATIC);
 			}
 
@@ -1081,14 +994,12 @@ static void rtl_op_bss_info_changed(stru
 					mac->mode = WIRELESS_MODE_N_5G;
 			}
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
 			if (sta->vht_cap.vht_supported) {
 				if (rtlhal->current_bandtype == BAND_ON_5G)
 					mac->mode = WIRELESS_MODE_AC_5G;
 				else
 					mac->mode = WIRELESS_MODE_AC_24G;
 			}
-#endif
 
 			rcu_read_unlock();
 
@@ -1225,15 +1136,12 @@ static void rtl_op_bss_info_changed(stru
 				mac->mode = WIRELESS_MODE_N_5G;
 		}
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
 		if (sta->vht_cap.vht_supported) {
 			if (rtlhal->current_bandtype == BAND_ON_5G)
 				mac->mode = WIRELESS_MODE_AC_5G;
 			else
 				mac->mode = WIRELESS_MODE_AC_24G;
 		}
-#endif
-
 
 		/* just station need it, because ibss & ap mode will
 		 * set in sta_add, and will be NULL here */
@@ -1254,11 +1162,8 @@ static void rtl_op_bss_info_changed(stru
 			 * */
 		}
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
-		if (sta->vht_cap.vht_supported) {
+		if (sta->vht_cap.vht_supported)
 			mac->vht_enable = true;
-		}
-#endif
 
 		if (changed & BSS_CHANGED_BASIC_RATES) {
 			/* for 5G must << RATE_6M_INDEX=4,
@@ -1278,11 +1183,7 @@ out:
 	mutex_unlock(&rtlpriv->locks.conf_mutex);
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
 static u64 rtl_op_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
-#else
-static u64 rtl_op_get_tsf(struct ieee80211_hw *hw)
-#endif
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	u64 tsf;
@@ -1291,12 +1192,8 @@ static u64 rtl_op_get_tsf(struct ieee802
 	return tsf;
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
 static void rtl_op_set_tsf(struct ieee80211_hw *hw,
 			   struct ieee80211_vif *vif, u64 tsf)
-#else
-static void rtl_op_set_tsf(struct ieee80211_hw *hw, u64 tsf)
-#endif
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
@@ -1306,11 +1203,7 @@ static void rtl_op_set_tsf(struct ieee80
 	rtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_CORRECT_TSF, (u8 *) (&bibss));
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
 static void rtl_op_reset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
-#else
-static void rtl_op_reset_tsf(struct ieee80211_hw *hw)
-#endif
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	u8 tmp = 0;
@@ -1336,15 +1229,8 @@ static void rtl_op_sta_notify(struct iee
 static int rtl_op_ampdu_action(struct ieee80211_hw *hw,
 			       struct ieee80211_vif *vif,
 			       enum ieee80211_ampdu_mlme_action action,
-			       struct ieee80211_sta *sta, u16 tid, u16 *ssn
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
-/*<delete in kernel end>*/
-			       , u8 buf_size
-/*<delete in kernel start>*/
-#endif
-/*<delete in kernel end>*/
-			       )
+			       struct ieee80211_sta *sta, u16 tid, u16 *ssn,
+			       u8 buf_size)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 
@@ -1354,13 +1240,9 @@ static int rtl_op_ampdu_action(struct ie
 			 ("IEEE80211_AMPDU_TX_START: TID:%d\n", tid));
 		return rtl_tx_agg_start(hw, vif, sta, tid, ssn);
 		break;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))
 	case IEEE80211_AMPDU_TX_STOP_CONT:
 	case IEEE80211_AMPDU_TX_STOP_FLUSH:
 	case IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:
-#else
-	case IEEE80211_AMPDU_TX_STOP:
-#endif
 		RT_TRACE(COMP_MAC80211, DBG_TRACE,
 			 ("IEEE80211_AMPDU_TX_STOP: TID:%d\n", tid));
 		return rtl_tx_agg_stop(hw, vif, sta, tid);
@@ -1489,9 +1371,6 @@ static int rtl_op_set_key(struct ieee802
 	mutex_lock(&rtlpriv->locks.conf_mutex);
 	/* <1> get encryption alg */
 
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-/*<delete in kernel end>*/
 	switch (key->cipher) {
 	case WLAN_CIPHER_SUITE_WEP40:
 		key_type = WEP40_ENCRYPTION;
@@ -1524,43 +1403,6 @@ static int rtl_op_set_key(struct ieee802
 			 ("alg_err:%x!!!!:\n", key->cipher));
 		goto out_unlock;
 	}
-/*<delete in kernel start>*/
-#else
-	switch (key->alg) {
-	case ALG_WEP:
-		if (key->keylen == WLAN_KEY_LEN_WEP40) {
-			key_type = WEP40_ENCRYPTION;
-			RT_TRACE(COMP_SEC, DBG_DMESG, ("alg:WEP40\n"));
-		} else {
-			RT_TRACE(COMP_SEC, DBG_DMESG,
-				 ("alg:WEP104\n"));
-			key_type = WEP104_ENCRYPTION;
-		}
-		break;
-	case ALG_TKIP:
-		key_type = TKIP_ENCRYPTION;
-		RT_TRACE(COMP_SEC, DBG_DMESG, ("alg:TKIP\n"));
-		break;
-	case ALG_CCMP:
-		key_type = AESCCMP_ENCRYPTION;
-		RT_TRACE(COMP_SEC, DBG_DMESG, ("alg:CCMP\n"));
-		break;
-	case ALG_AES_CMAC:
-		/*HW don't support CMAC encryption, use software CMAC encryption */
-		key_type = AESCMAC_ENCRYPTION;
-		RT_TRACE(COMP_SEC, DBG_DMESG, ("alg:CMAC\n"));
-		RT_TRACE(COMP_SEC, DBG_DMESG,
-			 ("HW don't support CMAC encrypiton, "
-			  "use software CMAC encrypiton\n"));
-		err = -EOPNOTSUPP;
-		goto out_unlock;
-	default:
-		RT_TRACE(COMP_ERR, DBG_EMERG,
-			 ("alg_err:%x!!!!:\n", key->alg));
-		goto out_unlock;
-	}
-#endif
-/*<delete in kernel end>*/
 	if (key_type == WEP40_ENCRYPTION ||
 	   key_type == WEP104_ENCRYPTION ||
 	   vif->type == NL80211_IFTYPE_ADHOC)
@@ -1671,17 +1513,17 @@ static int rtl_op_set_key(struct ieee802
 		if (vif->type == NL80211_IFTYPE_AP ||
 			vif->type == NL80211_IFTYPE_MESH_POINT) {
 			if (sta)
-				rtl_cam_del_entry(hw, sta->addr);
+				stg_rtl_cam_del_entry(hw, sta->addr);
 		}
 		memset(rtlpriv->sec.key_buf[key_idx], 0, key->keylen);
 		rtlpriv->sec.key_len[key_idx] = 0;
 		memcpy(mac_addr, zero_addr, ETH_ALEN);
 		/*
 		 *mac80211 will delete entrys one by one,
-		 *so don't use rtl_cam_reset_all_entry
+		 *so don't use stg_rtl_cam_reset_all_entry
 		 *or clear all entry here.
 		 */
-		rtl_cam_delete_one_entry(hw, mac_addr, key_idx);
+		stg_rtl_cam_delete_one_entry(hw, mac_addr, key_idx);
 		break;
 	default:
 		RT_TRACE(COMP_ERR, DBG_EMERG,
@@ -1729,7 +1571,6 @@ static void rtl_op_rfkill_poll(struct ie
  * before switch channle or power save, or tx buffer packet
  * maybe send after offchannel or rf sleep, this may cause
  * dis-association by AP */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
 static void rtl_op_flush(struct ieee80211_hw *hw, u32 queues, bool drop)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
@@ -1737,15 +1578,6 @@ static void rtl_op_flush(struct ieee8021
 	if (rtlpriv->intf_ops->flush)
 		rtlpriv->intf_ops->flush(hw, queues, drop);
 }
-#else
-static void rtl_op_flush(struct ieee80211_hw *hw, bool drop)
-{
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-
-	if (rtlpriv->intf_ops->flush)
-		rtlpriv->intf_ops->flush(hw, drop);
-}
-#endif
 
 const struct ieee80211_ops rtl_ops = {
 	.start = rtl_op_start,
@@ -1753,9 +1585,7 @@ const struct ieee80211_ops rtl_ops = {
 	.tx = rtl_op_tx,
 	.add_interface = rtl_op_add_interface,
 	.remove_interface = rtl_op_remove_interface,
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
 	.change_interface = rtl_op_change_interface,
-#endif
 #ifdef CONFIG_PM
 	.suspend = rtl_op_suspend,
 	.resume = rtl_op_resume,
Index: linux-2.6/drivers/staging/rtl8192ee/debug.c
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/debug.c
+++ linux-2.6/drivers/staging/rtl8192ee/debug.c
@@ -30,11 +30,7 @@
 #include "wifi.h"
 #include "cam.h"
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
 #define GET_INODE_DATA(__node)		PDE_DATA(__node)
-#else
-#define GET_INODE_DATA(__node)		PDE(__node)->data
-#endif
 
 
 void rtl_dbgp_flag_init(struct ieee80211_hw *hw)
Index: linux-2.6/drivers/staging/rtl8192ee/efuse.c
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/efuse.c
+++ linux-2.6/drivers/staging/rtl8192ee/efuse.c
@@ -28,9 +28,6 @@
  *****************************************************************************/
 #include "wifi.h"
 #include "efuse.h"
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
-#include <linux/export.h>
-#endif
 
 static const u8 MAX_PGPKT_SIZE = 9;
 static const u8 PGPKT_DATA_SIZE = 8;
@@ -104,7 +101,7 @@ void efuse_initialize(struct ieee80211_h
 
 }
 
-u8 efuse_read_1byte(struct ieee80211_hw *hw, u16 address)
+u8 stg_efuse_read_1byte(struct ieee80211_hw *hw, u16 address)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	u8 data;
@@ -148,7 +145,7 @@ u8 efuse_read_1byte(struct ieee80211_hw
 		return 0xFF;
 
 }
-//EXPORT/g_SYMBOL(efuse_read_1byte);
+EXPORT_SYMBOL(stg_efuse_read_1byte);
 
 void efuse_write_1byte(struct ieee80211_hw *hw, u16 address, u8 value)
 {
@@ -414,7 +411,7 @@ void efuse_shadow_read(struct ieee80211_
 		efuse_shadow_read_4byte(hw, offset, (u32 *) value);
 
 }
-//EXPORT/g_SYMBOL(efuse_shadow_read);
+EXPORT_SYMBOL(efuse_shadow_read);
 
 void efuse_shadow_write(struct ieee80211_hw *hw, u8 type, u16 offset,
 				u32 value)
@@ -503,7 +500,7 @@ bool efuse_shadow_update(struct ieee8021
 	return true;
 }
 
-void rtl_efuse_shadow_map_update(struct ieee80211_hw *hw)
+void stg_rtl_efuse_shadow_map_update(struct ieee80211_hw *hw)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));
@@ -520,7 +517,7 @@ void rtl_efuse_shadow_map_update(struct
 			rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE]);
 
 }
-//EXPORT/g_SYMBOL(rtl_efuse_shadow_map_update);
+EXPORT_SYMBOL(stg_rtl_efuse_shadow_map_update);
 
 void efuse_force_write_vendor_Id(struct ieee80211_hw *hw)
 {
@@ -600,7 +597,7 @@ static void efuse_shadow_write_4byte(str
 
 }
 
-int efuse_one_byte_read(struct ieee80211_hw *hw, u16 addr, u8 *data)
+int stg_efuse_one_byte_read(struct ieee80211_hw *hw, u16 addr, u8 *data)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	u8 tmpidx = 0;
@@ -631,7 +628,7 @@ int efuse_one_byte_read(struct ieee80211
 	}
 	return bresult;
 }
-//EXPORT/g_SYMBOL(efuse_one_byte_read);
+EXPORT_SYMBOL(stg_efuse_one_byte_read);
 
 static int efuse_one_byte_write(struct ieee80211_hw *hw, u16 addr, u8 data)
 {
@@ -690,7 +687,7 @@ static void efuse_read_data_case1(struct
 
 	if (hoffset == offset) {
 		for (tmpidx = 0; tmpidx < word_cnts * 2; tmpidx++) {
-			if (efuse_one_byte_read(hw, *efuse_addr + 1 + tmpidx,
+			if (stg_efuse_one_byte_read(hw, *efuse_addr + 1 + tmpidx,
 						&efuse_data)) {
 				tmpdata[tmpidx] = efuse_data;
 				if (efuse_data != 0xff)
@@ -732,7 +729,7 @@ static int efuse_pg_packet_read(struct i
 
 	while (bcontinual && (efuse_addr < EFUSE_MAX_SIZE)) {
 		if (readstate & PG_STATE_HEADER) {
-			if (efuse_one_byte_read(hw, efuse_addr, &efuse_data)
+			if (stg_efuse_one_byte_read(hw, efuse_addr, &efuse_data)
 			    && (efuse_data != 0xFF))
 				efuse_read_data_case1(hw, &efuse_addr,
 						      efuse_data, offset,
@@ -782,7 +779,7 @@ static void efuse_write_data_case1(struc
 		*write_state = PG_STATE_HEADER;
 	} else {
 		for (tmpindex = 0; tmpindex < (tmp_word_cnts * 2); tmpindex++) {
-			if (efuse_one_byte_read(hw,
+			if (stg_efuse_one_byte_read(hw,
 						(*efuse_addr + 1 + tmpindex),
 						&efuse_data) &&
 			    (efuse_data != 0xFF))
@@ -880,7 +877,7 @@ static void efuse_write_data_case2(struc
 
 	pg_header = ((target_pkt.offset << 4) & 0xf0) | target_pkt.word_en;
 	efuse_one_byte_write(hw, *efuse_addr, pg_header);
-	efuse_one_byte_read(hw, *efuse_addr, &tmp_header);
+	stg_efuse_one_byte_read(hw, *efuse_addr, &tmp_header);
 
 	if (tmp_header == pg_header) {
 		*write_state = PG_STATE_DATA;
@@ -971,7 +968,7 @@ static int efuse_pg_packet_write(struct
 			RTPRINT(rtlpriv, FEEPROM, EFUSE_PG,
 				("efuse PG_STATE_HEADER\n"));
 
-			if (efuse_one_byte_read(hw, efuse_addr, &efuse_data) &&
+			if (stg_efuse_one_byte_read(hw, efuse_addr, &efuse_data) &&
 			    (efuse_data != 0xFF))
 				efuse_write_data_case1(hw, &efuse_addr,
 						       efuse_data, offset,
@@ -1071,8 +1068,8 @@ static u8 efuse_word_enable_data_write(s
 		efuse_one_byte_write(hw, start_addr++, data[0]);
 		efuse_one_byte_write(hw, start_addr++, data[1]);
 
-		efuse_one_byte_read(hw, tmpaddr, &tmpdata[0]);
-		efuse_one_byte_read(hw, tmpaddr + 1, &tmpdata[1]);
+		stg_efuse_one_byte_read(hw, tmpaddr, &tmpdata[0]);
+		stg_efuse_one_byte_read(hw, tmpaddr + 1, &tmpdata[1]);
 		if ((data[0] != tmpdata[0]) || (data[1] != tmpdata[1]))
 			badworden &= (~BIT(0));
 	}
@@ -1082,8 +1079,8 @@ static u8 efuse_word_enable_data_write(s
 		efuse_one_byte_write(hw, start_addr++, data[2]);
 		efuse_one_byte_write(hw, start_addr++, data[3]);
 
-		efuse_one_byte_read(hw, tmpaddr, &tmpdata[2]);
-		efuse_one_byte_read(hw, tmpaddr + 1, &tmpdata[3]);
+		stg_efuse_one_byte_read(hw, tmpaddr, &tmpdata[2]);
+		stg_efuse_one_byte_read(hw, tmpaddr + 1, &tmpdata[3]);
 		if ((data[2] != tmpdata[2]) || (data[3] != tmpdata[3]))
 			badworden &= (~BIT(1));
 	}
@@ -1093,8 +1090,8 @@ static u8 efuse_word_enable_data_write(s
 		efuse_one_byte_write(hw, start_addr++, data[4]);
 		efuse_one_byte_write(hw, start_addr++, data[5]);
 
-		efuse_one_byte_read(hw, tmpaddr, &tmpdata[4]);
-		efuse_one_byte_read(hw, tmpaddr + 1, &tmpdata[5]);
+		stg_efuse_one_byte_read(hw, tmpaddr, &tmpdata[4]);
+		stg_efuse_one_byte_read(hw, tmpaddr + 1, &tmpdata[5]);
 		if ((data[4] != tmpdata[4]) || (data[5] != tmpdata[5]))
 			badworden &= (~BIT(2));
 	}
@@ -1104,8 +1101,8 @@ static u8 efuse_word_enable_data_write(s
 		efuse_one_byte_write(hw, start_addr++, data[6]);
 		efuse_one_byte_write(hw, start_addr++, data[7]);
 
-		efuse_one_byte_read(hw, tmpaddr, &tmpdata[6]);
-		efuse_one_byte_read(hw, tmpaddr + 1, &tmpdata[7]);
+		stg_efuse_one_byte_read(hw, tmpaddr, &tmpdata[6]);
+		stg_efuse_one_byte_read(hw, tmpaddr + 1, &tmpdata[7]);
 		if ((data[6] != tmpdata[6]) || (data[7] != tmpdata[7]))
 			badworden &= (~BIT(3));
 	}
@@ -1207,7 +1204,7 @@ static u16 efuse_get_current_size(struct
 	u8 hoffset, hworden;
 	u8 efuse_data, word_cnts;
 
-	while (bcontinual && efuse_one_byte_read(hw, efuse_addr, &efuse_data)
+	while (bcontinual && stg_efuse_one_byte_read(hw, efuse_addr, &efuse_data)
 	       && (efuse_addr < EFUSE_MAX_SIZE)) {
 		if (efuse_data != 0xFF) {
 			hoffset = (efuse_data >> 4) & 0x0F;
Index: linux-2.6/drivers/staging/rtl8192ee/efuse.h
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/efuse.h
+++ linux-2.6/drivers/staging/rtl8192ee/efuse.h
@@ -113,8 +113,8 @@ struct efuse_priv {
 
 extern void read_efuse_byte(struct ieee80211_hw *hw, u16 _offset, u8 *pbuf);
 extern void efuse_initialize(struct ieee80211_hw *hw);
-extern u8 efuse_read_1byte(struct ieee80211_hw *hw, u16 address);
-extern int efuse_one_byte_read(struct ieee80211_hw *hw, u16 addr, u8 *data);
+extern u8 stg_efuse_read_1byte(struct ieee80211_hw *hw, u16 address);
+extern int stg_efuse_one_byte_read(struct ieee80211_hw *hw, u16 addr, u8 *data);
 extern void efuse_write_1byte(struct ieee80211_hw *hw, u16 address, u8 value);
 extern void read_efuse(struct ieee80211_hw *hw, u16 _offset,
 		       u16 _size_byte, u8 *pbuf);
@@ -124,7 +124,7 @@ extern void efuse_shadow_write(struct ie
 			       u16 offset, u32 value);
 extern bool efuse_shadow_update(struct ieee80211_hw *hw);
 extern bool efuse_shadow_update_chk(struct ieee80211_hw *hw);
-extern void rtl_efuse_shadow_map_update(struct ieee80211_hw *hw);
+extern void stg_rtl_efuse_shadow_map_update(struct ieee80211_hw *hw);
 extern void efuse_force_write_vendor_Id(struct ieee80211_hw *hw);
 extern void efuse_re_pg_section(struct ieee80211_hw *hw, u8 section_idx);
 #endif
Index: linux-2.6/drivers/staging/rtl8192ee/pci.c
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/pci.c
+++ linux-2.6/drivers/staging/rtl8192ee/pci.c
@@ -33,9 +33,9 @@
 #include "base.h"
 #include "ps.h"
 #include "efuse.h"
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
-#include <linux/export.h>
-#endif
+
+/* for single module build */
+int rtl_core_module_init(void);
 
 static const u16 pcibridge_vendors[PCI_BRIDGE_VENDOR_MAX] = {
 	INTEL_VENDOR_ID,
@@ -364,47 +364,6 @@ static bool rtl_pci_get_amd_l1_patch(str
 	return status;
 }
 
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35))
-static u8 _rtl_pci_get_pciehdr_offset(struct ieee80211_hw *hw)
-{
-	u8 capability_offset;
-	u8 num4bytes = 0x34/4;
-	struct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);
-	u32 pcicfg_addr_port = (pcipriv->ndis_adapter.pcibridge_busnum << 16)|
-			       (pcipriv->ndis_adapter.pcibridge_devnum << 11)|
-			       (pcipriv->ndis_adapter.pcibridge_funcnum << 8)|
-			       (1 << 31);
-
-	rtl_pci_raw_write_port_ulong(PCI_CONF_ADDRESS , pcicfg_addr_port
-							+ (num4bytes << 2));
-	rtl_pci_raw_read_port_uchar(PCI_CONF_DATA, &capability_offset);
-	while (capability_offset != 0) {
-		struct rtl_pci_capabilities_header capability_hdr;
-
-		num4bytes = capability_offset / 4;
-		/* Read the header of the capability at  this offset.
-		 * If the retrieved capability is not the power management
-		 * capability that we are looking for, follow the link to
-		 * the next capability and continue looping.
-		 */
-		rtl_pci_raw_write_port_ulong(PCI_CONF_ADDRESS ,
-					     pcicfg_addr_port +
-					     (num4bytes << 2));
-		rtl_pci_raw_read_port_ushort(PCI_CONF_DATA,
-					     (u16 *)&capability_hdr);
-		/* Found the PCI express capability. */
-		if (capability_hdr.capability_id ==
-		    PCI_CAPABILITY_ID_PCI_EXPRESS)
-			break;
-		else
-			capability_offset = capability_hdr.next;
-	}
-	return capability_offset;
-}
-#endif
-/*<delete in kernel end>*/
-
 bool rtl_pci_check_buddy_priv(struct ieee80211_hw *hw,
 			      struct rtl_priv **buddy_priv)
 {
@@ -610,14 +569,7 @@ static void _rtl_pci_tx_chk_waitq(struct
 				_rtl_pci_update_earlymode_info(hw, skb,
 							       &tcb_desc, tid);
 
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
-			rtlpriv->intf_ops->adapter_tx(hw, skb, &tcb_desc);
-#else
-/*<delete in kernel end>*/
 			rtlpriv->intf_ops->adapter_tx(hw, NULL, skb, &tcb_desc);
-#endif
-/*<delete in kernel end>*/
 		}
 	}
 }
@@ -1022,7 +974,6 @@ static irqreturn_t _rtl_pci_interrupt(in
 	rtl_write_dword(rtlpriv, rtlpriv->cfg->maps[MAC_HIMR], 0x0);
 	rtl_write_dword(rtlpriv, rtlpriv->cfg->maps[MAC_HIMRE], 0x0);
 
-
 	/*read ISR: 4/8bytes */
 	rtlpriv->cfg->ops->interrupt_recognized(hw, &inta, &intb);
 
@@ -1146,7 +1097,6 @@ static irqreturn_t _rtl_pci_interrupt(in
 		tasklet_schedule(&rtlpriv->works.irq_tasklet);
 
 done:
-
 	rtl_write_dword(rtlpriv, rtlpriv->cfg->maps[MAC_HIMR],
 			rtlpci->irq_mask[0]);
 	rtl_write_dword(rtlpriv, rtlpriv->cfg->maps[MAC_HIMRE],
@@ -1191,19 +1141,9 @@ static void _rtl_pci_prepare_bcn_tasklet
 	if (rtlpriv->use_new_trx_flow)
 		pbuffer_desc = &ring->buffer_desc[0];
 
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
-	rtlpriv->cfg->ops->fill_tx_desc(hw, hdr, (u8 *) pdesc,
-					(u8 *)pbuffer_desc, info, pskb,
-					BEACON_QUEUE, &tcb_desc);
-#else
-/*<delete in kernel end>*/
 	rtlpriv->cfg->ops->fill_tx_desc(hw, hdr, (u8 *) pdesc,
 					(u8 *)pbuffer_desc, info, NULL, pskb,
 					BEACON_QUEUE, &tcb_desc);
-/*<delete in kernel start>*/
-#endif
-/*<delete in kernel end>*/
 
 	__skb_queue_tail(&ring->queue, pskb);
 
@@ -1606,26 +1546,11 @@ int rtl_pci_reset_trx_ring(struct ieee80
 	return 0;
 }
 
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
-static bool rtl_pci_tx_chk_waitq_insert(struct ieee80211_hw *hw,
-					struct sk_buff *skb)
-#else
-/*<delete in kernel end>*/
 static bool rtl_pci_tx_chk_waitq_insert(struct ieee80211_hw *hw,
 					struct ieee80211_sta *sta,
 					struct sk_buff *skb)
-/*<delete in kernel start>*/
-#endif
-/*<delete in kernel end>*/
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-	struct ieee80211_sta *sta = info->control.sta;
-#endif
-/*<delete in kernel end>*/
 	struct rtl_sta_info *sta_entry = NULL;
 	u8 tid = rtl_get_tid(skb);
 	u16 fc = rtl_get_fc(skb);
@@ -1661,28 +1586,14 @@ static bool rtl_pci_tx_chk_waitq_insert(
 	return true;
 }
 
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
-int rtl_pci_tx(struct ieee80211_hw *hw, struct sk_buff *skb,
-	       struct rtl_tcb_desc *ptcb_desc)
-#else
-/*<delete in kernel end>*/
 static int rtl_pci_tx(struct ieee80211_hw *hw,
 		      struct ieee80211_sta *sta,
 		      struct sk_buff *skb,
 		      struct rtl_tcb_desc *ptcb_desc)
-/*<delete in kernel start>*/
-#endif
-/*<delete in kernel end>*/
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_sta_info *sta_entry = NULL;
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
-	struct ieee80211_sta *sta = info->control.sta;
-#endif
-/*<delete in kernel end>*/
 	struct rtl8192_tx_ring *ring;
 	struct rtl_tx_desc *pdesc;
 	struct rtl_tx_buffer_desc *ptx_bd_desc = NULL;
@@ -1766,19 +1677,9 @@ static int rtl_pci_tx(struct ieee80211_h
 	if (ieee80211_is_data(fc))
 		rtlpriv->cfg->ops->led_control(hw, LED_CTL_TX);
 
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
-	rtlpriv->cfg->ops->fill_tx_desc(hw, hdr, (u8 *) pdesc,
-					(u8 *)ptx_bd_desc, info, skb,
-					hw_queue, ptcb_desc);
-#else
-/*<delete in kernel end>*/
 	rtlpriv->cfg->ops->fill_tx_desc(hw, hdr, (u8 *) pdesc,
 					(u8 *)ptx_bd_desc, info, sta, skb,
 					hw_queue, ptcb_desc);
-/*<delete in kernel start>*/
-#endif
-/*<delete in kernel end>*/
 
 	__skb_queue_tail(&ring->queue, skb);
 	if (rtlpriv->use_new_trx_flow) {
@@ -1808,11 +1709,7 @@ static int rtl_pci_tx(struct ieee80211_h
 
 	return 0;
 }
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
 static void rtl_pci_flush(struct ieee80211_hw *hw, u32 queues, bool drop)
-#else
-static void rtl_pci_flush(struct ieee80211_hw *hw, bool drop)
-#endif
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);
@@ -1827,12 +1724,10 @@ static void rtl_pci_flush(struct ieee802
 
 	for (queue_id = RTL_PCI_MAX_TX_QUEUE_COUNT - 1; queue_id >= 0;) {
 		u32 queue_len;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
 		if (((queues >> queue_id) & 0x1) == 0) {
 			queue_id--;
 			continue;
 		}
-#endif
 		ring = &pcipriv->dev.tx_ring[queue_id];
 		queue_len = skb_queue_len(&ring->queue);
 		if (queue_len == 0 || queue_id == BEACON_QUEUE ||
@@ -2120,17 +2015,8 @@ static bool _rtl_pci_find_adapter(struct
 		    (pcipriv->ndis_adapter.pcibridge_busnum << 16) |
 		    (pcipriv->ndis_adapter.pcibridge_devnum << 11) |
 		    (pcipriv->ndis_adapter.pcibridge_funcnum << 8) | (1 << 31);
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
-/*<delete in kernel end>*/
 		pcipriv->ndis_adapter.pcibridge_pciehdr_offset =
 		    pci_pcie_cap(bridge_pdev);
-/*<delete in kernel start>*/
-#else
-		pcipriv->ndis_adapter.pcibridge_pciehdr_offset =
-			_rtl_pci_get_pciehdr_offset(hw);
-#endif
-/*<delete in kernel end>*/
 		pcipriv->ndis_adapter.num4bytes =
 		    (pcipriv->ndis_adapter.pcibridge_pciehdr_offset + 0x10) / 4;
 
@@ -2228,17 +2114,10 @@ static int rtl_pci_intr_mode_decide(stru
  * hw pointer in rtl_pci_get_hw_pointer */
 struct ieee80211_hw *hw_export = NULL;
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
-int rtl_pci_probe(struct pci_dev *pdev,
-			const struct pci_device_id *id)
-
-#else
-int __devinit rtl_pci_probe(struct pci_dev *pdev,
+int stg_rtl_pci_probe(struct pci_dev *pdev,
 			const struct pci_device_id *id)
-#endif
 {
 	struct ieee80211_hw *hw = NULL;
-
 	struct rtl_priv *rtlpriv = NULL;
 	struct rtl_pci_priv *pcipriv = NULL;
 	struct rtl_pci *rtlpci;
@@ -2330,6 +2209,9 @@ int __devinit rtl_pci_probe(struct pci_d
 	pci_write_config_byte(pdev, 0x04, 0x06);
 	pci_write_config_byte(pdev, 0x04, 0x07);
 
+	/* The next statement is needed when built as single module */
+	rtl_core_module_init();
+
 	/* find adapter */
 	/* if chip not support, will return false */
 	if (!_rtl_pci_find_adapter(pdev, hw))
@@ -2424,15 +2306,15 @@ fail1:
 	return -ENODEV;
 
 }
-//EXPORT/g_SYMBOL(rtl_pci_probe);
+EXPORT_SYMBOL(stg_rtl_pci_probe);
 
 struct ieee80211_hw *rtl_pci_get_hw_pointer(void)
 {
 	return hw_export;
 }
-//EXPORT/g_SYMBOL(rtl_pci_get_hw_pointer);
+EXPORT_SYMBOL(rtl_pci_get_hw_pointer);
 
-void rtl_pci_disconnect(struct pci_dev *pdev)
+void stg_rtl_pci_disconnect(struct pci_dev *pdev)
 {
 	struct ieee80211_hw *hw = pci_get_drvdata(pdev);
 	struct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);
@@ -2486,7 +2368,7 @@ void rtl_pci_disconnect(struct pci_dev *
 
 	ieee80211_free_hw(hw);
 }
-//EXPORT/g_SYMBOL(rtl_pci_disconnect);
+EXPORT_SYMBOL(stg_rtl_pci_disconnect);
 
 /***************************************
 kernel pci power state define:
@@ -2503,7 +2385,7 @@ call rtl_mac_stop() from the mac80211
 suspend function first, So there is
 no need to call hw_disable here.
 ****************************************/
-int rtl_pci_suspend(struct device *dev)
+int stg_rtl_pci_suspend(struct device *dev)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct ieee80211_hw *hw = pci_get_drvdata(pdev);
@@ -2514,9 +2396,9 @@ int rtl_pci_suspend(struct device *dev)
 
 	return 0;
 }
-//EXPORT/g_SYMBOL(rtl_pci_suspend);
+EXPORT_SYMBOL(stg_rtl_pci_suspend);
 
-int rtl_pci_resume(struct device *dev)
+int stg_rtl_pci_resume(struct device *dev)
 {
 	struct pci_dev *pdev = to_pci_dev(dev);
 	struct ieee80211_hw *hw = pci_get_drvdata(pdev);
@@ -2527,7 +2409,7 @@ int rtl_pci_resume(struct device *dev)
 
 	return 0;
 }
-//EXPORT/g_SYMBOL(rtl_pci_resume);
+EXPORT_SYMBOL(stg_rtl_pci_resume);
 
 struct rtl_intf_ops rtl_pci_ops = {
 	.read_efuse_byte = read_efuse_byte,
Index: linux-2.6/drivers/staging/rtl8192ee/pci.h
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/pci.h
+++ linux-2.6/drivers/staging/rtl8192ee/pci.h
@@ -280,16 +280,11 @@ int rtl_pci_reset_trx_ring(struct ieee80
 
 extern struct rtl_intf_ops rtl_pci_ops;
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
-int rtl_pci_probe(struct pci_dev *pdev,
+int stg_rtl_pci_probe(struct pci_dev *pdev,
 			const struct pci_device_id *id);
-#else
-int __devinit rtl_pci_probe(struct pci_dev *pdev,
-			const struct pci_device_id *id);
-#endif
-void rtl_pci_disconnect(struct pci_dev *pdev);
-int rtl_pci_suspend(struct device *dev);
-int rtl_pci_resume(struct device *dev);
+void stg_rtl_pci_disconnect(struct pci_dev *pdev);
+int stg_rtl_pci_suspend(struct device *dev);
+int stg_rtl_pci_resume(struct device *dev);
 
 static inline u8 pci_read8_sync(struct rtl_priv *rtlpriv, u32 addr)
 {
Index: linux-2.6/drivers/staging/rtl8192ee/ps.c
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/ps.c
+++ linux-2.6/drivers/staging/rtl8192ee/ps.c
@@ -30,12 +30,9 @@
 #include "wifi.h"
 #include "base.h"
 #include "ps.h"
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
-#include <linux/export.h>
-#endif
 #include "btcoexist/rtl_btc.h"
 
-bool rtl_ps_enable_nic(struct ieee80211_hw *hw)
+bool stg_rtl_ps_enable_nic(struct ieee80211_hw *hw)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));
@@ -62,9 +59,9 @@ bool rtl_ps_enable_nic(struct ieee80211_
 
 	return init_status;
 }
-//EXPORT/g_SYMBOL(rtl_ps_enable_nic);
+EXPORT_SYMBOL(stg_rtl_ps_enable_nic);
 
-bool rtl_ps_disable_nic(struct ieee80211_hw *hw)
+bool stg_rtl_ps_disable_nic(struct ieee80211_hw *hw)
 {
 	bool status = true;
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
@@ -80,9 +77,9 @@ bool rtl_ps_disable_nic(struct ieee80211
 
 	return status;
 }
-//EXPORT/g_SYMBOL(rtl_ps_disable_nic);
+EXPORT_SYMBOL(stg_rtl_ps_disable_nic);
 
-bool rtl_ps_set_rf_state(struct ieee80211_hw *hw,
+bool stg_rtl_ps_set_rf_state(struct ieee80211_hw *hw,
 			 enum rf_pwrstate state_toset,
 			 u32 changesource, bool protect_or_not)
 {
@@ -181,7 +178,7 @@ no_protect:
 
 	return b_actionallowed;
 }
-//EXPORT/g_SYMBOL(rtl_ps_set_rf_state);
+EXPORT_SYMBOL(stg_rtl_ps_set_rf_state);
 
 static void _rtl_ps_inactive_ps(struct ieee80211_hw *hw)
 {
@@ -200,7 +197,7 @@ static void _rtl_ps_inactive_ps(struct i
 		}
 	}
 
-	rtl_ps_set_rf_state(hw, ppsc->inactive_pwrstate,
+	stg_rtl_ps_set_rf_state(hw, ppsc->inactive_pwrstate,
 			    RF_CHANGE_BY_IPS, false);
 
 	if (ppsc->inactive_pwrstate == ERFOFF &&
@@ -464,7 +461,7 @@ void rtl_lps_enter(struct ieee80211_hw *
 
 	spin_unlock_irqrestore(&rtlpriv->locks.lps_lock, flag);
 }
-//EXPORT/g_SYMBOL(rtl_lps_enter);
+EXPORT_SYMBOL(rtl_lps_enter);
 
 /*Leave the leisure power save mode.*/
 void rtl_lps_leave(struct ieee80211_hw *hw)
@@ -497,7 +494,7 @@ void rtl_lps_leave(struct ieee80211_hw *
 	}
 	spin_unlock_irqrestore(&rtlpriv->locks.lps_lock, flag);
 }
-//EXPORT/g_SYMBOL(rtl_lps_leave);
+EXPORT_SYMBOL(rtl_lps_leave);
 
 /* For sw LPS*/
 void rtl_swlps_beacon(struct ieee80211_hw *hw, void *data, unsigned int len)
@@ -553,17 +550,8 @@ void rtl_swlps_beacon(struct ieee80211_h
 	tim_len = tim[1];
 	tim_ie = (struct ieee80211_tim_ie *) &tim[2];
 
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
-/*<delete in kernel end>*/
 	if (!WARN_ON_ONCE(!hw->conf.ps_dtim_period))
 		rtlpriv->psc.dtim_counter = tim_ie->dtim_count;
-/*<delete in kernel start>*/
-#else
-	if (!WARN_ON_ONCE(!mac->vif->bss_conf.dtim_period))
-		rtlpriv->psc.dtim_counter = tim_ie->dtim_count;
-#endif
-/*<delete in kernel end>*/
 
 	/* Check whenever the PHY can be turned off again. */
 
@@ -609,7 +597,7 @@ void rtl_swlps_rf_awake(struct ieee80211
 	}
 
 	spin_lock_irqsave(&rtlpriv->locks.lps_lock, flag);
-	rtl_ps_set_rf_state(hw, ERFON, RF_CHANGE_BY_PS, false);
+	stg_rtl_ps_set_rf_state(hw, ERFON, RF_CHANGE_BY_PS, false);
 	spin_unlock_irqrestore(&rtlpriv->locks.lps_lock, flag);
 }
 
@@ -652,7 +640,7 @@ void rtl_swlps_rf_sleep(struct ieee80211
 	spin_unlock(&rtlpriv->locks.rf_ps_lock);
 
 	spin_lock_irqsave(&rtlpriv->locks.lps_lock, flag);
-	rtl_ps_set_rf_state(hw, ERFSLEEP, RF_CHANGE_BY_PS , false);
+	stg_rtl_ps_set_rf_state(hw, ERFSLEEP, RF_CHANGE_BY_PS , false);
 	spin_unlock_irqrestore(&rtlpriv->locks.lps_lock, flag);
 
 	if (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_ASPM &&
@@ -667,9 +655,6 @@ void rtl_swlps_rf_sleep(struct ieee80211
 	 * time to sleep_intv = rtlpriv->psc.dtim_counter or
 	 * MAX_SW_LPS_SLEEP_INTV(default set to 5) */
 
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
-/*<delete in kernel end>*/
 	if (rtlpriv->psc.dtim_counter == 0) {
 		if (hw->conf.ps_dtim_period == 1)
 			sleep_intv = hw->conf.ps_dtim_period * 2;
@@ -678,18 +663,6 @@ void rtl_swlps_rf_sleep(struct ieee80211
 	} else {
 		sleep_intv = rtlpriv->psc.dtim_counter;
 	}
-/*<delete in kernel start>*/
-#else
-	if (rtlpriv->psc.dtim_counter == 0) {
-		if (mac->vif->bss_conf.dtim_period == 1)
-			sleep_intv = mac->vif->bss_conf.dtim_period * 2;
-		else
-			sleep_intv = mac->vif->bss_conf.dtim_period;
-	} else {
-		sleep_intv = rtlpriv->psc.dtim_counter;
-	}
-#endif
-/*<delete in kernel end>*/
 
 	if (sleep_intv > MAX_SW_LPS_SLEEP_INTV)
 		sleep_intv = MAX_SW_LPS_SLEEP_INTV;
Index: linux-2.6/drivers/staging/rtl8192ee/ps.h
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/ps.h
+++ linux-2.6/drivers/staging/rtl8192ee/ps.h
@@ -32,11 +32,11 @@
 
 #define MAX_SW_LPS_SLEEP_INTV	5
 
-bool rtl_ps_set_rf_state(struct ieee80211_hw *hw,
+bool stg_rtl_ps_set_rf_state(struct ieee80211_hw *hw,
 			 enum rf_pwrstate state_toset, u32 changesource,
 			 bool protect_or_not);
-bool rtl_ps_enable_nic(struct ieee80211_hw *hw);
-bool rtl_ps_disable_nic(struct ieee80211_hw *hw);
+bool stg_rtl_ps_enable_nic(struct ieee80211_hw *hw);
+bool stg_rtl_ps_disable_nic(struct ieee80211_hw *hw);
 void rtl_ips_nic_off(struct ieee80211_hw *hw);
 void rtl_ips_nic_on(struct ieee80211_hw *hw);
 void rtl_ips_nic_off_wq_callback(void *data);
Index: linux-2.6/drivers/staging/rtl8192ee/rc.c
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/rc.c
+++ linux-2.6/drivers/staging/rtl8192ee/rc.c
@@ -51,7 +51,7 @@ static u8 _rtl_rc_get_highest_rix(struct
 	 *this rate is no use for true rate, firmware
 	 *will control rate at all it just used for
 	 *1.show in iwconfig in B/G mode
-	 *2.in rtl_get_tcb_desc when we check rate is
+	 *2.in stg_rtl_get_tcb_desc when we check rate is
 	 *      1M we will not use FW rate but user rate.
 	 */
 
@@ -108,9 +108,7 @@ static void _rtl_rc_rate_set_series(stru
 	if (sta) {
 		sgi_20 = sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20;
 		sgi_40 = sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
 		sgi_80 = sta->vht_cap.cap & IEEE80211_VHT_CAP_SHORT_GI_80;
-#endif
 	}
 	rate->count = tries;
 	rate->idx = rix >= 0x00 ? rix : 0x00;
@@ -123,27 +121,21 @@ static void _rtl_rc_rate_set_series(stru
 			if (sta && (sta->ht_cap.cap &
 				    IEEE80211_HT_CAP_SUP_WIDTH_20_40))
 				rate->flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
 			if (sta && (sta->vht_cap.vht_supported))
 				rate->flags |= IEEE80211_TX_RC_80_MHZ_WIDTH;
-#endif
 		} else {
 			if (mac->bw_40)
 				rate->flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
 			if (mac->bw_80)
 				rate->flags |= IEEE80211_TX_RC_80_MHZ_WIDTH;
-#endif
 		}
 
 		if (sgi_20 || sgi_40 || sgi_80)
 			rate->flags |= IEEE80211_TX_RC_SHORT_GI;
 		if (sta && sta->ht_cap.ht_supported)
 			rate->flags |= IEEE80211_TX_RC_MCS;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
 		if (sta && sta->vht_cap.vht_supported)
 			rate->flags |= IEEE80211_TX_RC_VHT_MCS;
-#endif
 	}
 }
 
@@ -226,16 +218,8 @@ static void rtl_tx_status(void *ppriv,
 						       tid)) {
 					sta_entry->tids[tid].agg.agg_state =
 						RTL_AGG_PROGRESS;
-					/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38))
-					/*<delete in kernel end>*/
 					ieee80211_start_tx_ba_session(sta, tid,
 								      5000);
-					/*<delete in kernel start>*/
-#else
-					ieee80211_start_tx_ba_session(sta, tid);
-#endif
-					/*<delete in kernel end>*/
 				}
 			}
 		}
Index: linux-2.6/drivers/staging/rtl8192ee/regd.c
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/regd.c
+++ linux-2.6/drivers/staging/rtl8192ee/regd.c
@@ -158,10 +158,6 @@ static void _rtl_reg_apply_beaconing_fla
 	const struct ieee80211_reg_rule *reg_rule;
 	struct ieee80211_channel *ch;
 	unsigned int i;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 9, 0))
-	u32 bandwidth = 0;
-	int r;
-#endif
 
 	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
 
@@ -176,16 +172,9 @@ static void _rtl_reg_apply_beaconing_fla
 			    (ch->flags & IEEE80211_CHAN_RADAR))
 				continue;
 			if (initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE) {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))
 				reg_rule = freq_reg_info(wiphy, ch->center_freq);
 				if (IS_ERR(reg_rule))
 					continue;
-#else
-				r = freq_reg_info(wiphy, ch->center_freq,
-						  bandwidth, &reg_rule);
-				if (r)
-					continue;
-#endif
 
 				/*
 				 *If 11d had a rule for this channel ensure
@@ -219,10 +208,6 @@ static void _rtl_reg_apply_active_scan_f
 	struct ieee80211_supported_band *sband;
 	struct ieee80211_channel *ch;
 	const struct ieee80211_reg_rule *reg_rule;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 9, 0))
-	u32 bandwidth = 0;
-	int r;
-#endif
 
 	if (!wiphy->bands[IEEE80211_BAND_2GHZ])
 		return;
@@ -250,26 +235,16 @@ static void _rtl_reg_apply_active_scan_f
 	 */
 
 	ch = &sband->channels[11];	/* CH 12 */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))
 	reg_rule = freq_reg_info(wiphy, ch->center_freq);
 	if (!IS_ERR(reg_rule)) {
-#else
-	r = freq_reg_info(wiphy, ch->center_freq, bandwidth, &reg_rule);
-	if (!r) {
-#endif
 		if (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))
 			if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
 				ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
 	}
 
 	ch = &sband->channels[12];	/* CH 13 */
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))
 	reg_rule = freq_reg_info(wiphy, ch->center_freq);
 	if (!IS_ERR(reg_rule)) {
-#else
-	r = freq_reg_info(wiphy, ch->center_freq, bandwidth, &reg_rule);
-	if (!r) {
-#endif
 		if (!(reg_rule->flags & NL80211_RRF_PASSIVE_SCAN))
 			if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
 				ch->flags &= ~IEEE80211_CHAN_PASSIVE_SCAN;
@@ -389,33 +364,19 @@ static const struct ieee80211_regdomain
 	}
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))
 static int _rtl_regd_init_wiphy(struct rtl_regulatory *reg,
 				struct wiphy *wiphy,
 				void (*reg_notifier) (struct wiphy *wiphy,
 						     struct regulatory_request *
 						     request))
-#else
-static int _rtl_regd_init_wiphy(struct rtl_regulatory *reg,
-				struct wiphy *wiphy,
-				int (*reg_notifier) (struct wiphy *wiphy,
-						     struct regulatory_request *
-						     request))
-#endif
 {
 	const struct ieee80211_regdomain *regd;
 
 	wiphy->reg_notifier = reg_notifier;
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
-    wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;
-    wiphy->regulatory_flags &= ~REGULATORY_STRICT_REG;
-    wiphy->regulatory_flags &= ~REGULATORY_DISABLE_BEACON_HINTS;
-#else
-	wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;
-	wiphy->flags &= ~WIPHY_FLAG_STRICT_REGULATORY;
-	wiphy->flags &= ~WIPHY_FLAG_DISABLE_BEACON_HINTS;
-#endif
+	wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;
+	wiphy->regulatory_flags &= ~REGULATORY_STRICT_REG;
+	wiphy->regulatory_flags &= ~REGULATORY_DISABLE_BEACON_HINTS;
 
 	regd = _rtl_regdomain_select(reg);
 	wiphy_apply_custom_regulatory(wiphy, regd);
@@ -435,15 +396,9 @@ static struct country_code_to_enum_rd *_
 	return NULL;
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))
 int rtl_regd_init(struct ieee80211_hw *hw,
 			void (*reg_notifier) (struct wiphy *wiphy,
 			struct regulatory_request *request))
-#else
-int rtl_regd_init(struct ieee80211_hw *hw,
-			int (*reg_notifier) (struct wiphy *wiphy,
-			struct regulatory_request *request))
-#endif
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct wiphy *wiphy = hw->wiphy;
@@ -486,7 +441,6 @@ int rtl_regd_init(struct ieee80211_hw *h
 	return 0;
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))
 void rtl_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request)
 {
 	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
@@ -496,14 +450,3 @@ void rtl_reg_notifier(struct wiphy *wiph
 
 	_rtl_reg_notifier_apply(wiphy, request, &rtlpriv->regd);
 }
-#else
-int rtl_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request)
-{
-	struct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);
-	struct rtl_priv *rtlpriv = rtl_priv(hw);
-
-	RT_TRACE(COMP_REGD, DBG_LOUD, ("\n"));
-
-	return _rtl_reg_notifier_apply(wiphy, request, &rtlpriv->regd);
-}
-#endif
Index: linux-2.6/drivers/staging/rtl8192ee/regd.h
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/regd.h
+++ linux-2.6/drivers/staging/rtl8192ee/regd.h
@@ -30,18 +30,9 @@
 #ifndef __RTL_REGD_H__
 #define __RTL_REGD_H__
 
-
-
 /* for kernel 3.14 , both value are changed to IEEE80211_CHAN_NO_IR*/
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
 #define IEEE80211_CHAN_NO_IBSS IEEE80211_CHAN_NO_IR
 #define IEEE80211_CHAN_PASSIVE_SCAN IEEE80211_CHAN_NO_IR
-#endif
-
-
-
-
-
 
 struct country_code_to_enum_rd {
 	u16 countrycode;
@@ -67,16 +58,9 @@ enum country_code_type_t {
 	COUNTRY_CODE_MAX
 };
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0))
 int rtl_regd_init(struct ieee80211_hw *hw,
 			void (*reg_notifier)(struct wiphy *wiphy,
 			struct regulatory_request *request));
 void rtl_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request);
-#else
-int rtl_regd_init(struct ieee80211_hw *hw,
-			int (*reg_notifier)(struct wiphy *wiphy,
-			struct regulatory_request *request));
-int rtl_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request);
-#endif
 
 #endif
Index: linux-2.6/drivers/staging/rtl8192ee/rtl8192ee/hw.c
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/rtl8192ee/hw.c
+++ linux-2.6/drivers/staging/rtl8192ee/rtl8192ee/hw.c
@@ -361,7 +361,7 @@ void rtl92ee_get_hw_reg(struct ieee80211
 
 		break; }
 	default:
-		RT_TRACE(COMP_ERR, DBG_EMERG,
+		RT_TRACE(COMP_ERR, DBG_LOUD,
 			 ("switch case not process %x\n", variable));
 		break;
 	}
@@ -585,7 +585,7 @@ void rtl92ee_set_hw_reg(struct ieee80211
 				acm_ctrl &= (~AcmHw_BeqEn);
 				break;
 			default:
-				RT_TRACE(COMP_ERR, DBG_EMERG,
+				RT_TRACE(COMP_ERR, DBG_LOUD,
 					 ("switch case not process \n"));
 				break;
 			}
@@ -693,7 +693,7 @@ void rtl92ee_set_hw_reg(struct ieee80211
 		rtl92ee_fill_h2c_cmd(hw, H2C_92E_KEEP_ALIVE_CTRL, 2, array);
 		break; }
 	default:
-		RT_TRACE(COMP_ERR, DBG_EMERG,
+		RT_TRACE(COMP_ERR, DBG_LOUD,
 			 ("switch case not process %x\n", variable));
 		break;
 	}
@@ -1254,7 +1254,7 @@ int rtl92ee_hw_init(struct ieee80211_hw
 
 	rtlhal->b_mac_func_enable = true;
 
-	rtl_cam_reset_all_entry(hw);
+	stg_rtl_cam_reset_all_entry(hw);
 	rtl92ee_enable_hw_security_config(hw);
 
 	ppsc->rfpwr_state = ERFON;
@@ -1280,7 +1280,7 @@ int rtl92ee_hw_init(struct ieee80211_hw
 	if (rtlphy->rf_type == RF_2T2R)
 		rtlphy->rfpath_rx_enable[1] = true;
 
-	efuse_one_byte_read(hw, 0x1FA, &tmp_u1b);
+	stg_efuse_one_byte_read(hw, 0x1FA, &tmp_u1b);
 	if (!(tmp_u1b & BIT(0))) {
 		rtl_set_rfreg(hw, RF90_PATH_A, 0x15, 0x0F, 0x05);
 		RT_TRACE(COMP_INIT, DBG_LOUD, ("PA BIAS path A\n"));
@@ -1469,17 +1469,26 @@ void rtl92ee_enable_interrupt(struct iee
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
-	u32 tmp;
 
+
+
+	u32 tmp;
 	tmp = rtl_read_dword(rtlpriv, REG_HISR);
+	/*printk("clear interrupt first:\n");
+	printk("0x%x = 0x%08x\n",REG_HISR, tmp);*/
 	rtl_write_dword(rtlpriv, REG_HISR, tmp);
 
 	tmp = rtl_read_dword(rtlpriv, REG_HISRE);
+	/*printk("0x%x = 0x%08x\n",REG_HISRE, tmp);*/
 	rtl_write_dword(rtlpriv, REG_HISRE, tmp);
 
 	tmp = rtl_read_dword(rtlpriv, REG_HSISR);
+	/*printk("0x%x = 0x%08x\n",REG_HSISR, tmp);*/
 	rtl_write_dword(rtlpriv, REG_HSISR, tmp);
 
+
+
+
 	rtl_write_dword(rtlpriv, REG_HIMR, rtlpci->irq_mask[0] & 0xFFFFFFFF);
 	rtl_write_dword(rtlpriv, REG_HIMRE, rtlpci->irq_mask[1] & 0xFFFFFFFF);
 	rtlpci->irq_enabled = true;
@@ -2001,7 +2010,7 @@ static void _rtl92ee_read_adapter_info(s
 	u16 eeprom_id;
 
 	if (rtlefuse->epromtype == EEPROM_BOOT_EFUSE) {
-		rtl_efuse_shadow_map_update(hw);
+		stg_rtl_efuse_shadow_map_update(hw);
 
 		memcpy(hwinfo, &rtlefuse->efuse_map[EFUSE_INIT_MAP][0],
 		       HWSET_MAX_SIZE);
@@ -2015,7 +2024,7 @@ static void _rtl92ee_read_adapter_info(s
 		return;
 	}
 
-	RT_PRINT_DATA(rtlpriv, COMP_INIT, DBG_DMESG, ("MAP \n"),
+	RT_PRINT_DATA(rtlpriv, COMP_INIT, DBG_LOUD, ("MAP \n"),
 		      hwinfo, HWSET_MAX_SIZE);
 
 	eeprom_id = *((u16 *) &hwinfo[0]);
@@ -2383,8 +2392,8 @@ void rtl92ee_set_key(struct ieee80211_hw
 		RT_TRACE(COMP_SEC, DBG_DMESG, ("clear_all\n"));
 
 		for (idx = 0; idx < clear_number; idx++) {
-			rtl_cam_mark_invalid(hw, cam_offset + idx);
-			rtl_cam_empty_entry(hw, cam_offset + idx);
+			stg_rtl_cam_mark_invalid(hw, cam_offset + idx);
+			stg_rtl_cam_empty_entry(hw, cam_offset + idx);
 
 			if (idx < 5) {
 				memset(rtlpriv->sec.key_buf[idx], 0,
@@ -2408,7 +2417,7 @@ void rtl92ee_set_key(struct ieee80211_hw
 			enc_algo = CAM_AES;
 			break;
 		default:
-			RT_TRACE(COMP_ERR, DBG_EMERG,
+			RT_TRACE(COMP_ERR, DBG_LOUD,
 				 ("switch case not process \n"));
 			enc_algo = CAM_TKIP;
 			break;
@@ -2424,7 +2433,7 @@ void rtl92ee_set_key(struct ieee80211_hw
 			} else {
 				if (mac->opmode == NL80211_IFTYPE_AP ||
 				    mac->opmode == NL80211_IFTYPE_MESH_POINT) {
-					entry_id = rtl_cam_get_free_entry(hw,
+					entry_id = stg_rtl_cam_get_free_entry(hw,
 								     p_macaddr);
 					if (entry_id >=  TOTAL_CAM_ENTRY) {
 						RT_TRACE(COMP_SEC, DBG_EMERG,
@@ -2446,15 +2455,15 @@ void rtl92ee_set_key(struct ieee80211_hw
 				 entry_id));
 			if (mac->opmode == NL80211_IFTYPE_AP ||
 			    mac->opmode == NL80211_IFTYPE_MESH_POINT)
-				rtl_cam_del_entry(hw, p_macaddr);
-			rtl_cam_delete_one_entry(hw, p_macaddr, entry_id);
+				stg_rtl_cam_del_entry(hw, p_macaddr);
+			stg_rtl_cam_delete_one_entry(hw, p_macaddr, entry_id);
 		} else {
 			RT_TRACE(COMP_SEC, DBG_DMESG, ("add one entry\n"));
 			if (is_pairwise) {
 				RT_TRACE(COMP_SEC, DBG_DMESG,
 					 ("set Pairwiase key\n"));
 
-				rtl_cam_add_one_entry(hw, macaddr, key_index,
+				stg_rtl_cam_add_one_entry(hw, macaddr, key_index,
 					       entry_id, enc_algo,
 					       CAM_CONFIG_NO_USEDK,
 					       rtlpriv->sec.key_buf[key_index]);
@@ -2463,7 +2472,7 @@ void rtl92ee_set_key(struct ieee80211_hw
 					 ("set group key\n"));
 
 				if (mac->opmode == NL80211_IFTYPE_ADHOC) {
-					rtl_cam_add_one_entry(hw,
+					stg_rtl_cam_add_one_entry(hw,
 						rtlefuse->dev_addr,
 						PAIRWISE_KEYIDX,
 						CAM_PAIRWISE_KEY_POSITION,
@@ -2471,7 +2480,7 @@ void rtl92ee_set_key(struct ieee80211_hw
 						rtlpriv->sec.key_buf[entry_id]);
 				}
 
-				rtl_cam_add_one_entry(hw, macaddr, key_index,
+				stg_rtl_cam_add_one_entry(hw, macaddr, key_index,
 						entry_id, enc_algo,
 						CAM_CONFIG_NO_USEDK,
 						rtlpriv->sec.key_buf[entry_id]);
Index: linux-2.6/drivers/staging/rtl8192ee/rtl8192ee/led.c
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/rtl8192ee/led.c
+++ linux-2.6/drivers/staging/rtl8192ee/rtl8192ee/led.c
@@ -41,25 +41,21 @@ static void _rtl92ee_init_led(struct iee
 
 void rtl92ee_sw_led_on(struct ieee80211_hw *hw, struct rtl_led *pled)
 {
-	u8 ledcfg;
+	u32 ledcfg;
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 
 	RT_TRACE(COMP_LED, DBG_LOUD,
 		 ("LedAddr:%X ledpin=%d\n", REG_LEDCFG2, pled->ledpin));
 
-
-
 	switch (pled->ledpin) {
 	case LED_PIN_GPIO0:
 		break;
 	case LED_PIN_LED0:
-		ledcfg = rtl_read_byte(rtlpriv, REG_LEDCFG2);
-		rtl_write_byte(rtlpriv,
-			       REG_LEDCFG2, (ledcfg & 0xf0) | BIT(5) | BIT(6));
+		ledcfg = rtl_read_dword(rtlpriv, REG_GPIO_PIN_CTRL) | BIT(21);
+		ledcfg &= ~BIT(13) & ~BIT(29);
+		rtl_write_dword(rtlpriv, REG_GPIO_PIN_CTRL, ledcfg);
 		break;
 	case LED_PIN_LED1:
-		ledcfg = rtl_read_byte(rtlpriv, REG_LEDCFG1);
-		rtl_write_byte(rtlpriv, REG_LEDCFG1, ledcfg & 0x10);
 		break;
 	default:
 		RT_TRACE(COMP_ERR, DBG_EMERG,
@@ -72,8 +68,7 @@ void rtl92ee_sw_led_on(struct ieee80211_
 void rtl92ee_sw_led_off(struct ieee80211_hw *hw, struct rtl_led *pled)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
-	struct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);
-	u8 ledcfg;
+	u32 ledcfg;
 
 	RT_TRACE(COMP_LED, DBG_LOUD,
 		 ("LedAddr:%X ledpin=%d\n", REG_LEDCFG2, pled->ledpin));
@@ -82,25 +77,14 @@ void rtl92ee_sw_led_off(struct ieee80211
 	case LED_PIN_GPIO0:
 		break;
 	case LED_PIN_LED0:
-		ledcfg = rtl_read_byte(rtlpriv, REG_LEDCFG2);
-		ledcfg &= 0xf0;
-		if (pcipriv->ledctl.bled_opendrain == true) {
-			rtl_write_byte(rtlpriv, REG_LEDCFG2,
-				       (ledcfg | BIT(3) | BIT(5) | BIT(6)));
-			ledcfg = rtl_read_byte(rtlpriv, REG_MAC_PINMUX_CFG);
-			rtl_write_byte(rtlpriv, REG_MAC_PINMUX_CFG,
-				       (ledcfg & 0xFE));
-		} else
-			rtl_write_byte(rtlpriv, REG_LEDCFG2,
-				       (ledcfg | BIT(3) | BIT(5) | BIT(6)));
+		ledcfg = rtl_read_dword(rtlpriv ,REG_GPIO_PIN_CTRL) | ~BIT(21);
+		ledcfg &= ~BIT(29);
+		rtl_write_dword(rtlpriv, REG_GPIO_PIN_CTRL, ledcfg);
 		break;
 	case LED_PIN_LED1:
-		ledcfg = rtl_read_byte(rtlpriv, REG_LEDCFG1);
-		ledcfg &= 0x10;
-		rtl_write_byte(rtlpriv, REG_LEDCFG1, (ledcfg | BIT(3)));
 		break;
 	default:
-		RT_TRACE(COMP_ERR, DBG_EMERG,
+		RT_TRACE(COMP_ERR, DBG_LOUD,
 			 ("switch case not process\n"));
 		break;
 	}
Index: linux-2.6/drivers/staging/rtl8192ee/rtl8192ee/phy.c
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/rtl8192ee/phy.c
+++ linux-2.6/drivers/staging/rtl8192ee/rtl8192ee/phy.c
@@ -3145,7 +3145,7 @@ static bool _rtl92ee_phy_set_rf_power_st
 				InitializeCount++;
 				RT_TRACE(COMP_RF, DBG_DMESG,
 					 ("IPS Set eRf nic enable\n"));
-				rtstatus = rtl_ps_enable_nic(hw);
+				rtstatus = stg_rtl_ps_enable_nic(hw);
 			} while ((rtstatus != true)
 				 && (InitializeCount < 10));
 			RT_CLEAR_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);
@@ -3194,7 +3194,7 @@ static bool _rtl92ee_phy_set_rf_power_st
 		if (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_HALT_NIC) {
 			RT_TRACE(COMP_RF, DBG_DMESG,
 				 ("IPS Set eRf nic disable\n"));
-			rtl_ps_disable_nic(hw);
+			stg_rtl_ps_disable_nic(hw);
 			RT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);
 		} else {
 			if (ppsc->rfoff_reason == RF_CHANGE_BY_IPS) {
Index: linux-2.6/drivers/staging/rtl8192ee/rtl8192ee/sw.c
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/rtl8192ee/sw.c
+++ linux-2.6/drivers/staging/rtl8192ee/rtl8192ee/sw.c
@@ -102,7 +102,7 @@ int rtl92ee_init_sw_vars(struct ieee8021
 	rtl92ee_bt_reg_init(hw);
 
 	rtlpci->msi_support = true;
-	rtlpriv->btcoexist.btc_ops = rtl_btc_get_ops_pointer();
+	rtlpriv->btcoexist.btc_ops = stg_rtl_btc_get_ops_pointer();
 
 	rtlpriv->dm.b_dm_initialgain_enable = 1;
 	rtlpriv->dm.dm_flag = 0;
@@ -374,17 +374,10 @@ struct rtl_hal_cfg rtl92ee_hal_cfg = {
 	.maps[RTL_RC_HT_RATEMCS15] = DESC92C_RATEMCS15,
 };
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
 static struct pci_device_id rtl92ee_pci_ids[] = {
 	{RTL_PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x818B, rtl92ee_hal_cfg)},
 	{},
 };
-#else
-static struct pci_device_id rtl92ee_pci_ids[] __devinitdata = {
-	{RTL_PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x818B, rtl92ee_hal_cfg)},
-	{},
-};
-#endif
 
 MODULE_DEVICE_TABLE(pci, rtl92ee_pci_ids);
 
@@ -404,16 +397,45 @@ MODULE_PARM_DESC(ips, "using no link pow
 MODULE_PARM_DESC(fwlps, "using linked fw control power save (default 1 is open)\n");
 MODULE_PARM_DESC(debug, "Set debug level (0-5) (default 0)");
 
-static const SIMPLE_DEV_PM_OPS(rtlwifi_pm_ops, rtl_pci_suspend, rtl_pci_resume);
+static const SIMPLE_DEV_PM_OPS(rtlwifi_pm_ops, stg_rtl_pci_suspend, stg_rtl_pci_resume);
 
 static struct pci_driver rtl92ee_driver = {
 	.name = KBUILD_MODNAME,
 	.id_table = rtl92ee_pci_ids,
-	.probe = rtl_pci_probe,
-	.remove = rtl_pci_disconnect,
+	.probe = stg_rtl_pci_probe,
+	.remove = stg_rtl_pci_disconnect,
 
 	.driver.pm = &rtlwifi_pm_ops,
 };
 
-module_pci_driver(rtl92ee_driver);
+#ifndef BUILD_ALONE
+extern int rtl_core_module_init(void);
+extern void rtl_core_module_exit(void);
+#endif
+static int __init rtl92ee_module_init(void)
+{
+	int ret;
+#ifndef BUILD_ALONE
+	ret = rtl_core_module_init();
+	if (ret)
+		return ret;
+
+#endif
+
+	ret = pci_register_driver(&rtl92ee_driver);
+	if (ret)
+		RT_ASSERT(false, (": No device found\n"));
+
+	return ret;
+}
+
+static void __exit rtl92ee_module_exit(void)
+{
+	pci_unregister_driver(&rtl92ee_driver);
+#ifndef BUILD_ALONE
+	rtl_core_module_exit();
+#endif
+}
 
+module_init(rtl92ee_module_init);
+module_exit(rtl92ee_module_exit);
Index: linux-2.6/drivers/staging/rtl8192ee/rtl8192ee/trx.c
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/rtl8192ee/trx.c
+++ linux-2.6/drivers/staging/rtl8192ee/rtl8192ee/trx.c
@@ -78,11 +78,7 @@ static int _rtl92ee_rate_mapping(struct
 	int rate_idx;
 
 	if (false == isht) {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
 		if (IEEE80211_BAND_2GHZ == hw->conf.chandef.chan->band) {
-#else
-		if (IEEE80211_BAND_2GHZ == hw->conf.channel->band) {
-#endif
 			switch (desc_rate) {
 			case DESC92C_RATE1M:
 				rate_idx = 0;
@@ -285,7 +281,7 @@ static void _rtl92ee_query_rxphystatus(s
 				break;
 		}
 		rx_pwr_all += 16;
-		pwdb_all = rtl_query_rxpwrpercentage(rx_pwr_all);
+		pwdb_all = stg_rtl_query_rxpwrpercentage(rx_pwr_all);
 
 		if (cck_highpwr == false) {
 			if (pwdb_all >= 80)
@@ -334,7 +330,7 @@ static void _rtl92ee_query_rxphystatus(s
 
 			pstatus->rx_pwr[i] = rx_pwr[i];
 			/* Translate DBM to percentage. */
-			rssi = rtl_query_rxpwrpercentage(rx_pwr[i]);
+			rssi = stg_rtl_query_rxpwrpercentage(rx_pwr[i]);
 			total_rssi += rssi;
 
 			pstatus->rx_mimo_signalstrength[i] = (u8)rssi;
@@ -345,7 +341,7 @@ static void _rtl92ee_query_rxphystatus(s
 		rx_pwr_all = ((p_phystrpt->cck_sig_qual_ofdm_pwdb_all >> 1)
 			      & 0x7f) - 110;
 
-		pwdb_all = rtl_query_rxpwrpercentage(rx_pwr_all);
+		pwdb_all = stg_rtl_query_rxpwrpercentage(rx_pwr_all);
 		pstatus->rx_pwdb_all = pwdb_all;
 		pstatus->bt_rx_rssi_percentage = pwdb_all;
 		pstatus->rxpower = rx_pwr_all;
@@ -359,7 +355,7 @@ static void _rtl92ee_query_rxphystatus(s
 			max_spatial_stream = 1;
 
 		for (i = 0; i < max_spatial_stream; i++) {
-			evm = rtl_evm_db_to_percentage(
+			evm = stg_rtl_evm_db_to_percentage(
 						p_phystrpt->stream_rxevm[i]);
 
 			if (bpacket_match_bssid) {
@@ -388,10 +384,10 @@ static void _rtl92ee_query_rxphystatus(s
 	/* UI BSS List signal strength(in percentage),
 	 * make it good looking, from 0~100. */
 	if (b_is_cck)
-		pstatus->signalstrength = (u8)(rtl_signal_scale_mapping(hw,
+		pstatus->signalstrength = (u8)(stg_rtl_signal_scale_mapping(hw,
 								     pwdb_all));
 	else if (rf_rx_num != 0)
-		pstatus->signalstrength = (u8)(rtl_signal_scale_mapping(hw,
+		pstatus->signalstrength = (u8)(stg_rtl_signal_scale_mapping(hw,
 						      total_rssi /= rf_rx_num));
 }
 
@@ -453,7 +449,7 @@ static void _rtl92ee_translate_rx_signal
 	_rtl92ee_query_rxphystatus(hw, pstatus, pdesc, p_drvinfo,
 				   b_packet_matchbssid, b_packet_toself,
 				   b_packet_beacon);
-	rtl_process_phyinfo(hw, tmp_buf, pstatus);
+	stg_rtl_process_phyinfo(hw, tmp_buf, pstatus);
 }
 
 static void _rtl92ee_insert_emcontent(struct rtl_tcb_desc *ptcb_desc,
@@ -543,13 +539,8 @@ bool rtl92ee_rx_query_desc(struct ieee80
 		RT_TRACE(COMP_RXDESC , DBG_LOUD,
 			 ("GGGGGGGGGGGGGet Wakeup Packet!! WakeMatch=%d\n",
 			 status->wake_match));
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
 	rx_status->freq = hw->conf.chandef.chan->center_freq;
 	rx_status->band = hw->conf.chandef.chan->band;
-#else
-	rx_status->freq = hw->conf.channel->center_freq;
-	rx_status->band = hw->conf.channel->band;
-#endif
 
 	hdr = (struct ieee80211_hdr *)(skb->data + status->rx_drvinfo_size +
 				       status->rx_bufshift + 24);
@@ -580,7 +571,7 @@ bool rtl92ee_rx_query_desc(struct ieee80
 				return false;
 		}
 
-		if ((!_ieee80211_is_robust_mgmt_frame(hdr)) &&
+		if ((!ieee80211_is_robust_mgmt_frame(hdr)) &&
 		    (ieee80211_has_protected(hdr->frame_control)))
 			rx_status->flag |= RX_FLAG_DECRYPTED;
 		else
@@ -838,15 +829,6 @@ void rtl92ee_pre_fill_tx_bd_desc(struct
 	SET_TX_DESC_TX_BUFFER_SIZE(desc, (u16)(pkt_len));
 }
 
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
-void rtl92ee_tx_fill_desc(struct ieee80211_hw *hw,
-			  struct ieee80211_hdr *hdr, u8 *pdesc_tx,
-			  u8 *pbd_desc_tx,
-			  struct ieee80211_tx_info *info, struct sk_buff *skb,
-			  u8 hw_queue, struct rtl_tcb_desc *ptcb_desc)
-#else
-/*<delete in kernel end>*/
 void rtl92ee_tx_fill_desc(struct ieee80211_hw *hw,
 			  struct ieee80211_hdr *hdr, u8 *pdesc_tx,
 			  u8 *pbd_desc_tx,
@@ -854,19 +836,11 @@ void rtl92ee_tx_fill_desc(struct ieee802
 			  struct ieee80211_sta *sta,
 			  struct sk_buff *skb,
 			  u8 hw_queue, struct rtl_tcb_desc *ptcb_desc)
-/*<delete in kernel start>*/
-#endif
-/*<delete in kernel end>*/
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
 	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
 	struct rtl_hal *rtlhal = rtl_hal(rtlpriv);
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
-	struct ieee80211_sta *sta = info->control.sta;
-#endif
-/*<delete in kernel end>*/
 	u8 *pdesc = (u8 *) pdesc_tx;
 	u16 seq_number;
 	u16 fc = le16_to_cpu(hdr->frame_control);
@@ -889,7 +863,7 @@ void rtl92ee_tx_fill_desc(struct ieee802
 				IEEE80211_HT_CAP_SUP_WIDTH_20_40;
 	}
 	seq_number = (le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_SEQ) >> 4;
-	rtl_get_tcb_desc(hw, info, sta, skb, ptcb_desc);
+	stg_rtl_get_tcb_desc(hw, info, sta, skb, ptcb_desc);
 	/* reserve 8 byte for AMPDU early mode */
 	if (rtlhal->b_earlymode_enable) {
 		skb_push(skb, EM_HDR_LEN);
@@ -989,9 +963,6 @@ void rtl92ee_tx_fill_desc(struct ieee802
 		}
 		if (info->control.hw_key) {
 			struct ieee80211_key_conf *key = info->control.hw_key;
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-/*<delete in kernel end>*/
 			switch (key->cipher) {
 			case WLAN_CIPHER_SUITE_WEP40:
 			case WLAN_CIPHER_SUITE_WEP104:
@@ -1006,23 +977,6 @@ void rtl92ee_tx_fill_desc(struct ieee802
 				break;
 
 			}
-/*<delete in kernel start>*/
-#else
-			switch (key->alg) {
-			case ALG_WEP:
-			case ALG_TKIP:
-				SET_TX_DESC_SEC_TYPE(pdesc, 0x1);
-				break;
-			case ALG_CCMP:
-				SET_TX_DESC_SEC_TYPE(pdesc, 0x3);
-				break;
-			default:
-				SET_TX_DESC_SEC_TYPE(pdesc, 0x0);
-				break;
-
-			}
-#endif
-/*<delete in kernel end>*/
 		}
 
 		SET_TX_DESC_QUEUE_SEL(pdesc, fw_qsel);
Index: linux-2.6/drivers/staging/rtl8192ee/rtl8192ee/trx.h
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/rtl8192ee/trx.h
+++ linux-2.6/drivers/staging/rtl8192ee/rtl8192ee/trx.h
@@ -852,15 +852,6 @@ void rtl92ee_pre_fill_tx_bd_desc(struct
 				 struct sk_buff *skb, dma_addr_t addr);
 
 
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
-void rtl92ee_tx_fill_desc(struct ieee80211_hw *hw,
-			  struct ieee80211_hdr *hdr, u8 *pdesc_tx,
-			  u8 *pbd_desc_tx,
-			  struct ieee80211_tx_info *info, struct sk_buff *skb,
-			  u8 hw_queue, struct rtl_tcb_desc *ptcb_desc);
-#else
-/*<delete in kernel end>*/
 void rtl92ee_tx_fill_desc(struct ieee80211_hw *hw,
 			  struct ieee80211_hdr *hdr, u8 *pdesc_tx,
 			  u8 *pbd_desc_tx,
@@ -868,9 +859,6 @@ void rtl92ee_tx_fill_desc(struct ieee802
 			  struct ieee80211_sta *sta,
 			  struct sk_buff *skb,
 			  u8 hw_queue, struct rtl_tcb_desc *ptcb_desc);
-/*<delete in kernel start>*/
-#endif
-/*<delete in kernel end>*/
 bool rtl92ee_rx_query_desc(struct ieee80211_hw *hw,
 			   struct rtl_stats *status,
 			   struct ieee80211_rx_status *rx_status,
Index: linux-2.6/drivers/staging/rtl8192ee/stats.c
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/stats.c
+++ linux-2.6/drivers/staging/rtl8192ee/stats.c
@@ -28,11 +28,8 @@
  *****************************************************************************/
 #include "wifi.h"
 #include "stats.h"
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0))
-#include <linux/export.h>
-#endif
 
-u8 rtl_query_rxpwrpercentage(char antpower)
+u8 stg_rtl_query_rxpwrpercentage(char antpower)
 {
 	if ((antpower <= -100) || (antpower >= 20))
 		return 0;
@@ -41,9 +38,9 @@ u8 rtl_query_rxpwrpercentage(char antpow
 	else
 		return 100 + antpower;
 }
-//EXPORT/g_SYMBOL(rtl_query_rxpwrpercentage);
+EXPORT_SYMBOL(stg_rtl_query_rxpwrpercentage);
 
-u8 rtl_evm_db_to_percentage(char value)
+u8 stg_rtl_evm_db_to_percentage(char value)
 {
 	char ret_val;
 	ret_val = value;
@@ -59,7 +56,7 @@ u8 rtl_evm_db_to_percentage(char value)
 
 	return ret_val;
 }
-//EXPORT/g_SYMBOL(rtl_evm_db_to_percentage);
+EXPORT_SYMBOL(stg_rtl_evm_db_to_percentage);
 
 u8 rtl_evm_dbm_jaguar(char value)
 {
@@ -75,7 +72,7 @@ u8 rtl_evm_dbm_jaguar(char value)
 	ret_val  = ret_val >> 1;
 	return ret_val;
 }
-//EXPORT/g_SYMBOL(rtl_evm_dbm_jaguar);
+EXPORT_SYMBOL(rtl_evm_dbm_jaguar);
 
 long rtl_translate_todbm(struct ieee80211_hw *hw,
 			 u8 signal_strength_index)
@@ -87,7 +84,7 @@ long rtl_translate_todbm(struct ieee8021
 	return signal_power;
 }
 
-long rtl_signal_scale_mapping(struct ieee80211_hw *hw, long currsig)
+long stg_rtl_signal_scale_mapping(struct ieee80211_hw *hw, long currsig)
 {
 	long retsig;
 
@@ -114,7 +111,7 @@ long rtl_signal_scale_mapping(struct iee
 
 	return retsig;
 }
-//EXPORT/g_SYMBOL(rtl_signal_scale_mapping);
+EXPORT_SYMBOL(stg_rtl_signal_scale_mapping);
 
 void rtl_process_ui_rssi(struct ieee80211_hw *hw, struct rtl_stats *pstatus)
 {
@@ -285,7 +282,7 @@ static void rtl_process_ui_link_quality(
 	}
 }
 
-void rtl_process_phyinfo(struct ieee80211_hw *hw, u8 *buffer,
+void stg_rtl_process_phyinfo(struct ieee80211_hw *hw, u8 *buffer,
 			 struct rtl_stats *pstatus)
 {
 
@@ -296,4 +293,4 @@ void rtl_process_phyinfo(struct ieee8021
 	rtl_process_pwdb(hw, pstatus);
 	rtl_process_ui_link_quality(hw, pstatus);
 }
-//EXPORT/g_SYMBOL(rtl_process_phyinfo);
+EXPORT_SYMBOL(stg_rtl_process_phyinfo);
Index: linux-2.6/drivers/staging/rtl8192ee/stats.h
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/stats.h
+++ linux-2.6/drivers/staging/rtl8192ee/stats.h
@@ -37,11 +37,11 @@
 /* Rx smooth factor */
 #define	RX_SMOOTH_FACTOR			20
 
-u8 rtl_query_rxpwrpercentage(char antpower);
-u8 rtl_evm_db_to_percentage(char value);
+u8 stg_rtl_query_rxpwrpercentage(char antpower);
+u8 stg_rtl_evm_db_to_percentage(char value);
 u8 rtl_evm_dbm_jaguar(char value);
-long rtl_signal_scale_mapping(struct ieee80211_hw *hw, long currsig);
-void rtl_process_phyinfo(struct ieee80211_hw *hw, u8 *buffer,
+long stg_rtl_signal_scale_mapping(struct ieee80211_hw *hw, long currsig);
+void stg_rtl_process_phyinfo(struct ieee80211_hw *hw, u8 *buffer,
 			 struct rtl_stats *pstatus);
 
 #endif
Index: linux-2.6/drivers/staging/rtl8192ee/wifi.h
===================================================================
--- linux-2.6.orig/drivers/staging/rtl8192ee/wifi.h
+++ linux-2.6/drivers/staging/rtl8192ee/wifi.h
@@ -1937,13 +1937,7 @@ struct rtl_hal_ops {
 			      struct ieee80211_hdr *hdr,
 			      u8 *pdesc_tx, u8 *pbd_desc,
 			      struct ieee80211_tx_info *info,
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0))
-/*<delete in kernel end>*/
 			      struct ieee80211_sta *sta,
-/*<delete in kernel start>*/
-#endif
-/*<delete in kernel end>*/
 			      struct sk_buff *skb, u8 hw_queue,
 			      struct rtl_tcb_desc *ptcb_desc);
 	void (*fill_tx_cmddesc) (struct ieee80211_hw *hw, u8 *pdesc,
@@ -2005,36 +1999,15 @@ struct rtl_intf_ops {
 	bool (*check_buddy_priv)(struct ieee80211_hw *hw,
 			struct rtl_priv **buddy_priv);
 
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
-	int (*adapter_tx) (struct ieee80211_hw *hw, struct sk_buff *skb,
-			   struct rtl_tcb_desc *ptcb_desc);
-#else
-/*<delete in kernel end>*/
 	int (*adapter_tx) (struct ieee80211_hw *hw,
 			   struct ieee80211_sta *sta,
 			   struct sk_buff *skb,
 			   struct rtl_tcb_desc *ptcb_desc);
-/*<delete in kernel start>*/
-#endif
-/*<delete in kernel end>*/
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0))
 	void (*flush)(struct ieee80211_hw *hw, u32 queues, bool drop);
-#else
-	void (*flush)(struct ieee80211_hw *hw, bool drop);
-#endif
 	int (*reset_trx_ring) (struct ieee80211_hw *hw);
-/*<delete in kernel start>*/
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0))
-	bool (*waitq_insert) (struct ieee80211_hw *hw, struct sk_buff *skb);
-#else
-/*<delete in kernel end>*/
 	bool (*waitq_insert) (struct ieee80211_hw *hw,
 			      struct ieee80211_sta *sta,
 			      struct sk_buff *skb);
-/*<delete in kernel start>*/
-#endif
-/*<delete in kernel end>*/
 
 	/*pci */
 	void (*disable_aspm) (struct ieee80211_hw *hw);
@@ -2256,11 +2229,9 @@ struct rtl_priv {
 	  * 92ee use new trx flow. */
 	bool use_new_trx_flow;
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0))
 #ifdef CONFIG_PM
 	struct wiphy_wowlan_support wowlan;
 #endif
-#endif
 	/*This must be the last item so
 	   that it points to the data allocated
 	   beyond  this structure like:
